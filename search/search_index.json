{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ESPAsyncWebServer","text":"<p>Asynchronous HTTP and WebSocket Server Library for ESP32, ESP8266, RP2040 and RP2350</p> <p>Supports: WebSocket, SSE, Authentication, Arduino Json 7, MessagePack, File Upload, Static File serving, URL Rewrite, URL Redirect, etc.</p>"},{"location":"#overview","title":"Overview","text":"<ul> <li>Using asynchronous network means that you can handle more than one connection at the same time</li> <li>You are called once the request is ready and parsed</li> <li>When you send the response, you are immediately ready to handle other connections   while the server is taking care of sending the response in the background</li> <li>Speed is OMG</li> <li>Easy to use API, HTTP Basic and Digest MD5 Authentication (default), ChunkedResponse</li> <li>Easily extendible to handle any type of content</li> <li>Supports Continue 100</li> <li>Async WebSocket plugin offering different locations without extra servers or ports</li> <li>Async EventSource (Server-Sent Events) plugin to send events to the browser</li> <li>URL Rewrite plugin for conditional and permanent url rewrites</li> <li>ServeStatic plugin that supports cache, Last-Modified, default index and more</li> <li>Simple template processing engine to handle templates</li> </ul>"},{"location":"#libraries-and-projects-that-use-asyncwebserver","title":"Libraries and projects that use AsyncWebServer","text":"<ul> <li>Beelance - Autonomous and remotely connected weight scale for beehives \ud83d\udc1d</li> <li>ElegantOTA - OTA updates made slick and simple for everyone!</li> <li>ESP Radio - Icecast radio based on ESP8266 and VS1053</li> <li>ESP-DASH - ESP-DASH is a library for ESP32 Arduino that facilitates the use of a dashboard in an asynchronous way. I have contributed most of the recently newly added fixes and features of the OSS and Pro version</li> <li>ESP-RFID - MFRC522 RFID Access Control Management project for ESP8266.</li> <li>ESPurna - ESPurna (\"spark\" in Catalan) is a custom C firmware for ESP8266 based smart switches. It was originally developed with the ITead Sonoff in mind.</li> <li>FauxmoESP - Belkin WeMo emulator library for ESP8266.</li> <li>MycilaESPConnect - Simple &amp; Easy Network Manager with Captive Portal for ESP32 supporting Ethernet</li> <li>MycilaJSY - Arduino / ESP32 library for the JSY1031, JSY-MK-163, JSY-MK-193, JSY-MK-194, JSY-MK-227, JSY-MK-229, JSY-MK-333 families single-phase and three-phase AC bidirectional meters from Shenzhen Jiansiyan Technologies Co, Ltd.</li> <li>MycilaWebSerial - WebSerial is a Serial Monitor for ESP32 that can be accessed remotely via a web browser</li> <li>NetWizard - No need to hard-code WiFi credentials ever again. (ESP32, RP2040+W)</li> <li>Sattrack - Track the ISS with ESP8266</li> <li>VZero - the Wireless zero-config controller for volkszaehler.org</li> <li>WebSerial - A remote terminal library for wireless microcontrollers to log, monitor or debug your firmware/product</li> <li>WebSocketToSerial - Debug serial devices through the web browser</li> <li>YaSolR (Yet another Solar Router) - Heat water with your Solar Production Excess with the more powerful and precise solar diverter out there!</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socioeconomic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at https://sidweb.nl/cms3/en/contact. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#principles-of-operation","title":"Principles of operation","text":""},{"location":"concepts/#the-async-web-server","title":"The Async Web server","text":"<ul> <li>Listens for connections</li> <li>Wraps the new clients into <code>Request</code></li> <li>Keeps track of clients and cleans memory</li> <li>Manages <code>Rewrites</code> and apply them on the request url</li> <li>Manages <code>Handlers</code> and attaches them to Requests</li> </ul>"},{"location":"concepts/#request-life-cycle","title":"Request Life Cycle","text":"<ul> <li>TCP connection is received by the server</li> <li>The connection is wrapped inside <code>Request</code> object</li> <li>When the request head is received (type, url, get params, http version and host),   the server goes through all <code>Rewrites</code> (in the order they were added) to rewrite the url and inject query parameters,   next, it goes through all attached <code>Handlers</code>(in the order they were added) trying to find one   that <code>canHandle</code> the given request. If none are found, the default(catch-all) handler is attached.</li> <li>The rest of the request is received, calling the <code>handleUpload</code> or <code>handleBody</code> methods of the <code>Handler</code> if they are needed (POST+File/Body)</li> <li>When the whole request is parsed, the result is given to the <code>handleRequest</code> method of the <code>Handler</code> and is ready to be responded to</li> <li>In the <code>handleRequest</code> method, to the <code>Request</code> is attached a <code>Response</code> object (see below) that will serve the response data back to the client</li> <li>When the <code>Response</code> is sent, the client is closed and freed from the memory</li> </ul>"},{"location":"concepts/#rewrites-and-how-do-they-work","title":"Rewrites and how do they work","text":"<ul> <li>The <code>Rewrites</code> are used to rewrite the request url and/or inject get parameters for a specific request url path.</li> <li>All <code>Rewrites</code> are evaluated on the request in the order they have been added to the server.</li> <li>The <code>Rewrite</code> will change the request url only if the request url (excluding get parameters) is fully match   the rewrite url, and when the optional <code>Filter</code> callback return true.</li> <li>Setting a <code>Filter</code> to the <code>Rewrite</code> enables to control when to apply the rewrite, decision can be based on   request url, http version, request host/port/target host, get parameters or the request client's localIP or remoteIP.</li> <li>Two filter callbacks are provided: <code>ON_AP_FILTER</code> to execute the rewrite when request is made to the AP interface,   <code>ON_STA_FILTER</code> to execute the rewrite when request is made to the STA interface.</li> <li>The <code>Rewrite</code> can specify a target url with optional get parameters, e.g. <code>/to-url?with=params</code></li> </ul>"},{"location":"concepts/#handlers-and-how-do-they-work","title":"Handlers and how do they work","text":"<ul> <li>The <code>Handlers</code> are used for executing specific actions to particular requests</li> <li>One <code>Handler</code> instance can be attached to any request and lives together with the server</li> <li>Setting a <code>Filter</code> to the <code>Handler</code> enables to control when to apply the handler, decision can be based on   request url, http version, request host/port/target host, get parameters or the request client's localIP or remoteIP.</li> <li>Two filter callbacks are provided: <code>ON_AP_FILTER</code> to execute the rewrite when request is made to the AP interface,   <code>ON_STA_FILTER</code> to execute the rewrite when request is made to the STA interface.</li> <li>The <code>canHandle</code> method is used for handler specific control on whether the requests can be handled   and for declaring any interesting headers that the <code>Request</code> should parse. Decision can be based on request   method, request url, http version, request host/port/target host and get parameters</li> <li>Once a <code>Handler</code> is attached to given <code>Request</code> (<code>canHandle</code> returned true)   that <code>Handler</code> takes care to receive any file/data upload and attach a <code>Response</code>   once the <code>Request</code> has been fully parsed</li> <li><code>Handlers</code> are evaluated in the order they are attached to the server. The <code>canHandle</code> is called only   if the <code>Filter</code> that was set to the <code>Handler</code> return true.</li> <li>The first <code>Handler</code> that can handle the request is selected, not further <code>Filter</code> and <code>canHandle</code> are called.</li> </ul>"},{"location":"concepts/#responses-and-how-do-they-work","title":"Responses and how do they work","text":"<ul> <li>The <code>Response</code> objects are used to send the response data back to the client</li> <li>The <code>Response</code> object lives with the <code>Request</code> and is freed on end or disconnect</li> <li>Different techniques are used depending on the response type to send the data in packets   returning back almost immediately and sending the next packet when this one is received.   Any time in between is spent to run the user loop and handle other network packets</li> <li>Responding asynchronously is probably the most difficult thing for most to understand</li> <li>Many different options exist for the user to make responding a background task</li> </ul>"},{"location":"concepts/#template-processing","title":"Template processing","text":"<ul> <li>ESPAsyncWebserver contains simple template processing engine.</li> <li>Template processing can be added to most response types.</li> <li>Currently it supports only replacing template placeholders with actual values. No conditional processing, cycles, etc.</li> <li>Placeholders are delimited with <code>%</code> symbols. Like this: <code>%TEMPLATE_PLACEHOLDER%</code>.</li> <li>It works by extracting placeholder name from response text and passing it to user provided function which should return actual value to be used instead of placeholder.</li> <li>Since it's user provided function, it is possible for library users to implement conditional processing and cycles themselves.</li> <li>Since it's impossible to know the actual response size after template processing step in advance (and, therefore, to include it in response headers), the response becomes chunked.</li> </ul>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#important-recommendations-for-build-options","title":"Important recommendations for build options","text":"<p>Most of the crashes are caused by improper use or configuration of the AsyncTCP library used for the project. Here are some recommendations to avoid them and build-time flags you can change.</p> <ul> <li> <p><code>CONFIG_ASYNC_TCP_MAX_ACK_TIME</code>: defines a timeout for TCP connection to be considered alive when waiting for data.   In some bad network conditions you might consider increasing it.</p> </li> <li> <p><code>CONFIG_ASYNC_TCP_QUEUE_SIZE</code>: defines the length of the queue for events related to connections handling.   Both the server and AsyncTCP library were optimized to control the queue automatically. Do NOT try blindly increasing the queue size, it does not help you in a way you might think it is. If you receive debug messages about queue throttling, try to optimize your server callbacks code to execute as fast as possible.</p> </li> <li> <p><code>CONFIG_ASYNC_TCP_RUNNING_CORE</code>: CPU core thread affinity that runs the queue events handling and executes server callbacks. Default is ANY core, so it means that for dualcore SoCs both cores could handle server activities. If your server's code is too heavy and unoptimized or you see that sometimes   server might affect other network activities, you might consider to bind it to the same core that runs Arduino code (1) to minimize affect on radio part. Otherwise you can leave the default to let RTOS decide where to run the thread based on priority</p> </li> <li> <p><code>CONFIG_ASYNC_TCP_STACK_SIZE</code>: stack size for the thread that runs sever events and callbacks. Default is 16k that is a way too much waste for well-defined short async code or simple static file handling. You might want to cosider reducing it to 4-8k to same RAM usage. If you do not know what this is or not sure about your callback code demands - leave it as default, should be enough even for very hungry callbacks in most cases.</p> </li> <li> <p><code>ASYNCWEBSERVER_USE_CHUNK_INFLIGHT</code>: inflight control for chunked responses.   If you need to serve chunk requests with a really low buffer (which should be avoided), you can set <code>-D ASYNCWEBSERVER_USE_CHUNK_INFLIGHT=0</code> to disable the in-flight control.</p> </li> </ul> <p>[!NOTE] This relates to ESP32 only, ESP8266 uses different ESPAsyncTCP lib that does not has this build options</p> <p>Recommended configurations:</p> <pre><code>  -D CONFIG_ASYNC_TCP_MAX_ACK_TIME=5000   // (keep default)\n  -D CONFIG_ASYNC_TCP_PRIORITY=10         // (keep default)\n  -D CONFIG_ASYNC_TCP_QUEUE_SIZE=64       // (keep default)\n  -D CONFIG_ASYNC_TCP_RUNNING_CORE=1      // force async_tcp task to be on same core as Arduino app (default is any core)\n  -D CONFIG_ASYNC_TCP_STACK_SIZE=4096     // reduce the stack size (default is 16K)\n</code></pre>"},{"location":"configuration/#important-things-to-remember","title":"Important things to remember","text":"<ul> <li>This is fully asynchronous server and as such does not run on the loop thread.</li> <li>You can not use yield or delay or any function that uses them inside the callbacks</li> <li>The server is smart enough to know when to close the connection and free resources</li> <li>You can not send more than one response to a single request</li> </ul>"},{"location":"eventsource/","title":"EventSource","text":""},{"location":"eventsource/#async-event-source-plugin","title":"Async Event Source Plugin","text":"<p>The server includes EventSource (Server-Sent Events) plugin which can be used to send short text events to the browser. Difference between EventSource and WebSockets is that EventSource is single direction, text-only protocol.</p> <p>See the ServerSentEvents example here.</p>"},{"location":"eventsource/#setup-event-source-on-the-server","title":"Setup Event Source on the server","text":"<pre><code>AsyncWebServer server(80);\nAsyncEventSource events(\"/events\");\n\nvoid setup(){\n  // setup ......\n  events.onConnect([](AsyncEventSourceClient *client){\n    if(client-&gt;lastId()){\n      Serial.printf(\"Client reconnected! Last message ID that it got is: %u\\n\", client-&gt;lastId());\n    }\n    //send event with message \"hello!\", id current millis\n    // and set reconnect delay to 1 second\n    client-&gt;send(\"hello!\",NULL,millis(),1000);\n  });\n\n  server.addHandler(&amp;events);\n  // setup ......\n}\n\nvoid loop(){\n  if(eventTriggered){ // your logic here\n    //send event \"myevent\"\n    events.send(\"my event content\",\"myevent\",millis());\n  }\n}\n</code></pre> <p>IMPORTANT: Use <code>AsyncAuthenticationMiddleware</code> instead of the deprecated <code>setAuthentication()</code> method for authentication.</p> <pre><code>AsyncAuthenticationMiddleware authMiddleware;\nauthMiddleware.setAuthType(AsyncAuthType::AUTH_DIGEST);\nauthMiddleware.setRealm(\"My app name\");\nauthMiddleware.setUsername(\"admin\");\nauthMiddleware.setPassword(\"admin\");\nauthMiddleware.generateHash();\n\nevents.addMiddleware(&amp;authMiddleware);\n</code></pre>"},{"location":"eventsource/#setup-event-source-in-the-browser","title":"Setup Event Source in the browser","text":"<pre><code>if (!!window.EventSource) {\n  var source = new EventSource(\"/events\");\n\n  source.addEventListener(\n    \"open\",\n    function (e) {\n      console.log(\"Events Connected\");\n    },\n    false,\n  );\n\n  source.addEventListener(\n    \"error\",\n    function (e) {\n      if (e.target.readyState != EventSource.OPEN) {\n        console.log(\"Events Disconnected\");\n      }\n    },\n    false,\n  );\n\n  source.addEventListener(\n    \"message\",\n    function (e) {\n      console.log(\"message\", e.data);\n    },\n    false,\n  );\n\n  source.addEventListener(\n    \"myevent\",\n    function (e) {\n      console.log(\"myevent\", e.data);\n    },\n    false,\n  );\n}\n</code></pre>"},{"location":"filters/","title":"Filters","text":""},{"location":"filters/#using-filters","title":"Using filters","text":"<p>Filters can be set to <code>Rewrite</code> or <code>Handler</code> in order to control when to apply the rewrite and consider the handler. A filter is a callback function that evaluates the request and return a boolean <code>true</code> to include the item or <code>false</code> to exclude it. Two filter callback are provided for convince:</p> <ul> <li><code>ON_STA_FILTER</code> - return true when requests are made to the STA (station mode) interface.</li> <li><code>ON_AP_FILTER</code> - return true when requests are made to the AP (access point) interface.</li> </ul> <p>See the Filters example here.</p>"},{"location":"filters/#serve-different-site-files-in-ap-mode","title":"Serve different site files in AP mode","text":"<pre><code>// For SPIFFS\nserver.serveStatic(\"/\", SPIFFS, \"/www/\").setFilter(ON_STA_FILTER);\nserver.serveStatic(\"/\", SPIFFS, \"/ap/\").setFilter(ON_AP_FILTER);\n\n// For LittleFS\nserver.serveStatic(\"/\", LittleFS, \"/www/\").setFilter(ON_STA_FILTER);\nserver.serveStatic(\"/\", LittleFS, \"/ap/\").setFilter(ON_AP_FILTER);\n</code></pre>"},{"location":"filters/#rewrite-to-different-index-on-ap","title":"Rewrite to different index on AP","text":"<pre><code>// Serve the file \"/www/index-ap.htm\" in AP, and the file \"/www/index.htm\" on STA (SPIFFS)\nserver.rewrite(\"/\", \"index.htm\");\nserver.rewrite(\"/index.htm\", \"index-ap.htm\").setFilter(ON_AP_FILTER);\nserver.serveStatic(\"/\", SPIFFS, \"/www/\");\n\n// Serve the file \"/www/index-ap.htm\" in AP, and the file \"/www/index.htm\" on STA (LittleFS)\nserver.rewrite(\"/\", \"index.htm\");\nserver.rewrite(\"/index.htm\", \"index-ap.htm\").setFilter(ON_AP_FILTER);\nserver.serveStatic(\"/\", LittleFS, \"/www/\");\n</code></pre>"},{"location":"filters/#serving-different-hosts","title":"Serving different hosts","text":"<pre><code>// Filter callback using request host\nbool filterOnHost1(AsyncWebServerRequest *request) { return request-&gt;host() == \"host1\"; }\n\n// Server setup: server files in \"/host1/\" to requests for \"host1\", and files in \"/www/\" otherwise (SPIFFS).\nserver.serveStatic(\"/\", SPIFFS, \"/host1/\").setFilter(filterOnHost1);\nserver.serveStatic(\"/\", SPIFFS, \"/www/\");\n\n// Server setup: server files in \"/host1/\" to requests for \"host1\", and files in \"/www/\" otherwise (LittleFS).\nserver.serveStatic(\"/\", LittleFS, \"/host1/\").setFilter(filterOnHost1);\nserver.serveStatic(\"/\", LittleFS, \"/www/\");\n</code></pre>"},{"location":"filters/#determine-interface-inside-callbacks","title":"Determine interface inside callbacks","text":"<pre><code>  String RedirectUrl = \"http://\";\n  if (ON_STA_FILTER(request)) {\n    RedirectUrl += WiFi.localIP().toString();\n  } else {\n    RedirectUrl += WiFi.softAPIP().toString();\n  }\n  RedirectUrl += \"/index.htm\";\n  request-&gt;redirect(RedirectUrl);\n</code></pre>"},{"location":"help_and_issues/","title":"Help &amp; Issues","text":"<p>We welcome contributions and questions from the community!</p>"},{"location":"help_and_issues/#getting-help","title":"Getting Help","text":"<p>If you have questions about how to use the library, need help with your code, or want to discuss features:</p> <ul> <li>Please do not open a GitHub Issue. Issues are reserved for bug reports and verifiable feature requests.</li> <li>Instead, open a discussion in the GitHub Discussions tab. This is the best place to get help from maintainers and other users.</li> </ul>"},{"location":"help_and_issues/#reporting-issues","title":"Reporting Issues","text":"<p>If you believe you have found a bug in the library, or if you have a specific feature request:</p> <ul> <li>Please open an Issue on the GitHub Issues tab.</li> <li>Be sure to include as much detail as possible, including:</li> <li>The version of the library you are using.</li> <li>The hardware you are running on (e.g., ESP32 S3, ESP8266, etc).</li> <li>A minimal code example that reproduces the issue.</li> <li>Any relevant logs or error messages (Enable Core Debug Level to Verbose).</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#compatibility","title":"Compatibility","text":"<ul> <li>ESP32, ESP8266, RP2040, RP2350</li> <li>Arduino Core 2.x and 3.x</li> </ul>"},{"location":"installation/#how-to-install","title":"How to install","text":"<p>The library can be downloaded from the releases page at https://github.com/ESP32Async/ESPAsyncWebServer/releases.</p> <p>It is also deployed in these registries:</p> <ul> <li> <p>Arduino Library Registry: https://github.com/arduino/library-registry</p> </li> <li> <p>Espressif Component Registry https://components.espressif.com/components/esp32async/espasyncwebserver</p> </li> <li> <p>PlatformIO Registry: https://registry.platformio.org/libraries/ESP32Async/ESPAsyncWebServer</p> </li> <li>Use: <code>lib_deps=ESP32Async/ESPAsyncWebServer</code> to point to latest version</li> <li>Use: <code>lib_deps=ESP32Async/ESPAsyncWebServer @ ^&lt;x.y.z&gt;</code> to point to latest version with the same major version</li> <li>Use: <code>lib_deps=ESP32Async/ESPAsyncWebServer @ &lt;x.y.z&gt;</code> to always point to the same version (reproducible build)</li> </ul>"},{"location":"installation/#dependencies","title":"Dependencies","text":""},{"location":"installation/#esp32-pioarduino","title":"ESP32 / pioarduino","text":"<pre><code>[env:stable]\nplatform = https://github.com/pioarduino/platform-espressif32/releases/download/stable/platform-espressif32.zip\nlib_compat_mode = strict\nlib_ldf_mode = chain\nlib_deps =\n  ESP32Async/AsyncTCP\n  ESP32Async/ESPAsyncWebServer\n</code></pre>"},{"location":"installation/#esp8266-pioarduino","title":"ESP8266 / pioarduino","text":"<pre><code>[env:stable]\nplatform = espressif8266\nlib_compat_mode = strict\nlib_ldf_mode = chain\nlib_deps =\n  ESP32Async/ESPAsyncTCP\n  ESP32Async/ESPAsyncWebServer\n</code></pre>"},{"location":"installation/#libretiny-bk7231nt-rtl8710b-etc","title":"LibreTiny (BK7231N/T, RTL8710B, etc.)","text":"<p>Version 1.9.1 or newer is required.</p> <pre><code>[env:stable]\nplatform = libretiny @ ^1.9.1\nlib_ldf_mode = chain\nlib_deps =\n  ESP32Async/AsyncTCP\n  ESP32Async/ESPAsyncWebServer\n</code></pre>"},{"location":"installation/#unofficial-dependencies","title":"Unofficial dependencies","text":"<p>AsyncTCPSock</p> <p>AsyncTCPSock can be used instead of AsyncTCP by excluding AsyncTCP from the library dependencies and adding AsyncTCPSock instead:</p> <pre><code>lib_compat_mode = strict\nlib_ldf_mode = chain\nlib_deps =\n  https://github.com/ESP32Async/AsyncTCPSock/archive/refs/tags/v1.0.3-dev.zip\n  ESP32Async/ESPAsyncWebServer\nlib_ignore =\n  AsyncTCP\n  ESP32Async/AsyncTCP\n</code></pre> <p>RPAsyncTCP</p> <p>RPAsyncTCP replaces AsyncTCP to provide support for RP2040(+WiFi) and RP2350(+WiFi) boards. For example - Raspberry Pi Pico W and Raspberry Pi Pico 2W.</p> <pre><code>lib_compat_mode = strict\nlib_ldf_mode = chain\nplatform = https://github.com/maxgerhardt/platform-raspberrypi.git\nboard = rpipicow\nboard_build.core = earlephilhower\nlib_deps =\n  ayushsharma82/RPAsyncTCP@^1.3.2\n  ESP32Async/ESPAsyncWebServer\nlib_ignore =\n  lwIP_ESPHost\nbuild_flags = ${env.build_flags}\n  -Wno-missing-field-initializers\n</code></pre>"},{"location":"middleware/","title":"Middleware","text":""},{"location":"middleware/#middleware_1","title":"Middleware","text":""},{"location":"middleware/#how-to-use-middleware","title":"How to use Middleware","text":"<p>Middleware is a way to intercept requests to perform some operations on them, like authentication, authorization, logging, etc and also act on the response headers.</p> <p>Middleware can either be attached to individual handlers, attached at the server level (thus applied to all handlers), or both. They will be executed in the order they are attached, and they can stop the request processing by sending a response themselves.</p> <p>You can have a look at the examples for some use cases.</p> <p>For example, such middleware would handle authentication and set some attributes on the request to make them available for the next middleware and for the handler which will process the request.</p> <pre><code>AsyncMiddlewareFunction complexAuth([](AsyncWebServerRequest* request, ArMiddlewareNext next) {\n  if (!request-&gt;authenticate(\"user\", \"password\")) {\n    return request-&gt;requestAuthentication();\n  }\n\n  request-&gt;setAttribute(\"user\", \"Mathieu\");\n  request-&gt;setAttribute(\"role\", \"staff\");\n\n  next(); // continue processing\n\n  // you can act one the response object\n  request-&gt;getResponse()-&gt;addHeader(\"X-Rate-Limit\", \"200\");\n});\n</code></pre> <p>Here are the list of available middlewares:</p> <ul> <li><code>AsyncMiddlewareFunction</code>: can convert a lambda function (<code>ArMiddlewareCallback</code>) to a middleware</li> <li><code>AsyncAuthenticationMiddleware</code>: to handle basic/digest authentication globally or per handler</li> <li><code>AsyncAuthorizationMiddleware</code>: to handle authorization globally or per handler</li> <li><code>AsyncCorsMiddleware</code>: to handle CORS preflight request globally or per handler</li> <li><code>AsyncHeaderFilterMiddleware</code>: to filter out headers from the request</li> <li><code>AsyncHeaderFreeMiddleware</code>: to only keep some headers from the request, and remove the others</li> <li><code>LoggerMiddleware</code>: to log requests globally or per handler with the same pattern as curl. Will also record request processing time</li> <li><code>AsyncRateLimitMiddleware</code>: to limit the number of requests on a windows of time globally or per handler</li> </ul> <p>See the Middleware example here.</p>"},{"location":"middleware/#cors-with-asynccorsmiddleware","title":"CORS with AsyncCorsMiddleware","text":"<p>You can handle CORS preflight requests and headers using <code>AsyncCorsMiddleware</code>.</p> <pre><code>static AsyncCorsMiddleware cors;\n\nvoid setup() {\n  // Configure CORS\n  cors.setOrigin(\"http://my-client-app.com\");\n  cors.setMethods(\"POST, GET, OPTIONS, DELETE\");\n  cors.setHeaders(\"X-Custom-Header\");\n  cors.setAllowCredentials(true);\n  cors.setMaxAge(600);\n\n  // Add middleware to server (valid for all handlers)\n  server.addMiddleware(&amp;cors);\n\n  // Or add to specific handler only\n  // server.on(\"/api/data\", HTTP_GET, handleData).addMiddleware(&amp;cors);\n}\n</code></pre>"},{"location":"middleware/#rate-limiting-with-asyncratelimitmiddleware","title":"Rate Limiting with AsyncRateLimitMiddleware","text":"<p>You can limit the number of requests within a time window using <code>AsyncRateLimitMiddleware</code>.</p> <pre><code>static AsyncRateLimitMiddleware rateLimit;\n\nvoid setup() {\n  // Allow maximum 5 requests per 10 seconds\n  rateLimit.setMaxRequests(5);\n  rateLimit.setWindowSize(10);\n\n  // Apply globally\n  // server.addMiddleware(&amp;rateLimit);\n\n  // OR apply to specific sensitive endpoint\n  server.on(\"/login\", HTTP_POST, handleLogin).addMiddleware(&amp;rateLimit);\n}\n</code></pre>"},{"location":"middleware/#authentication-with-asyncauthenticationmiddleware","title":"Authentication with AsyncAuthenticationMiddleware","text":"<p>IMPORTANT: Do not use the <code>setUsername()</code> and <code>setPassword()</code> methods on the handlers anymore. They are deprecated. These methods were causing a copy of the username and password for each handler, which is not efficient.</p> <p>Now, you can use the <code>AsyncAuthenticationMiddleware</code> to handle authentication globally or per handler.</p> <pre><code>AsyncAuthenticationMiddleware authMiddleware;\n\n// [...]\n\nauthMiddleware.setAuthType(AsyncAuthType::AUTH_DIGEST);\nauthMiddleware.setRealm(\"My app name\");\nauthMiddleware.setUsername(\"admin\");\nauthMiddleware.setPassword(\"admin\");\nauthMiddleware.setAuthFailureMessage(\"Authentication failed\");\nauthMiddleware.generateHash(); // optimization to avoid generating the hash at each request\n\n// [...]\n\nserver.addMiddleware(&amp;authMiddleware); // globally add authentication to the server\n\n// [...]\n\nmyHandler.addMiddleware(&amp;authMiddleware); // add authentication to a specific handler\n</code></pre> <p>See the Auth example here.</p>"},{"location":"middleware/#migration-to-middleware-to-improve-performance-and-memory-usage","title":"Migration to Middleware to improve performance and memory usage","text":"<ul> <li><code>AsyncEventSource.authorizeConnect(...)</code> =&gt; do not use this method anymore: add a common <code>AsyncAuthorizationMiddleware</code> to the handler or server, and make sure to add it AFTER the <code>AsyncAuthenticationMiddleware</code> if you use authentication.</li> <li><code>AsyncWebHandler.setAuthentication(...)</code> =&gt; do not use this method anymore: add a common <code>AsyncAuthenticationMiddleware</code> to the handler or server</li> <li><code>ArUploadHandlerFunction</code> and <code>ArBodyHandlerFunction</code> =&gt; these callbacks receiving body data and upload and not calling anymore the authentication code for performance reasons.   These callbacks can be called multiple times during request parsing, so this is up to the user to now call the <code>AsyncAuthenticationMiddleware.allowed(request)</code> if needed and ideally when the method is called for the first time.   These callbacks are also not triggering the whole middleware chain since they are not part of the request processing workflow (they are not the final handler).</li> </ul>"},{"location":"requests/","title":"Requests","text":""},{"location":"requests/#request-variables","title":"Request Variables","text":""},{"location":"requests/#common-variables","title":"Common Variables","text":"<pre><code>request-&gt;version();       // uint8_t: 0 = HTTP/1.0, 1 = HTTP/1.1\nrequest-&gt;method();        // enum:    HTTP_GET, HTTP_POST, HTTP_DELETE, HTTP_PUT, HTTP_PATCH, HTTP_HEAD, HTTP_OPTIONS\nrequest-&gt;url();           // String:  URL of the request (not including host, port or GET parameters)\nrequest-&gt;host();          // String:  The requested host (can be used for virtual hosting)\nrequest-&gt;contentType();   // String:  ContentType of the request (not available in Handler::canHandle)\nrequest-&gt;contentLength(); // size_t:  ContentLength of the request (not available in Handler::canHandle)\nrequest-&gt;multipart();     // bool:    True if the request has content type \"multipart\"\n</code></pre>"},{"location":"requests/#headers","title":"Headers","text":"<pre><code>//List all collected headers\nint headers = request-&gt;headers();\nint i;\nfor(i=0;i&lt;headers;i++){\n  const AsyncWebHeader* h = request-&gt;getHeader(i);\n  Serial.printf(\"HEADER[%s]: %s\\n\", h-&gt;name().c_str(), h-&gt;value().c_str());\n}\n\n//get specific header by name\nif(request-&gt;hasHeader(\"MyHeader\")){\n  const AsyncWebHeader* h = request-&gt;getHeader(\"MyHeader\");\n  Serial.printf(\"MyHeader: %s\\n\", h-&gt;value().c_str());\n}\n\n//List all collected headers (Compatibility)\nint headers = request-&gt;headers();\nint i;\nfor(i=0;i&lt;headers;i++){\n  Serial.printf(\"HEADER[%s]: %s\\n\", request-&gt;headerName(i).c_str(), request-&gt;header(i).c_str());\n}\n\n//get specific header by name (Compatibility)\nif(request-&gt;hasHeader(\"MyHeader\")){\n  Serial.printf(\"MyHeader: %s\\n\", request-&gt;header(\"MyHeader\").c_str());\n}\n</code></pre> <p>See the Headers example here.</p>"},{"location":"requests/#path-variable","title":"Path Variable","text":"<p>With path variable you can create a custom regex rule for a specific parameter in a route. For example we want a <code>sensorId</code> parameter in a route rule to match only a integer.</p> <pre><code>  server.on(\"^\\\\/sensor\\\\/([0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest *request) {\n      String sensorId = request-&gt;pathArg(0);\n  });\n</code></pre> <p>NOTE: All regex patterns starts with <code>^</code> and ends with <code>$</code></p> <p>To enable the <code>Path variable</code> support, you have to define the buildflag <code>-DASYNCWEBSERVER_REGEX</code>.</p> <p>For Arduino IDE create/update <code>platform.local.txt</code>:</p> <p><code>Windows</code>: C:\\Users(username)\\AppData\\Local\\Arduino15\\packages\\<code>{espxxxx}</code>\\hardware\\<code>espxxxx</code>\\<code>{version}</code>\\platform.local.txt</p> <p><code>Linux</code>: ~/.arduino15/packages/<code>{espxxxx}</code>/hardware/<code>{espxxxx}</code>/<code>{version}</code>/platform.local.txt</p> <p>Add/Update the following line:</p> <pre><code>  compiler.cpp.extra_flags=-DASYNCWEBSERVER_REGEX\n</code></pre> <p>For platformio modify <code>platformio.ini</code>:</p> <pre><code>[env:myboard]\nbuild_flags =\n  -DASYNCWEBSERVER_REGEX\n</code></pre> <p>NOTE: By enabling <code>ASYNCWEBSERVER_REGEX</code>, <code>&lt;regex&gt;</code> will be included. This will add an 100k to your binary.</p> <p>See the URIMatcher example here and URIMatcherTest example here.</p>"},{"location":"requests/#get-post-and-file-parameters","title":"GET, POST and FILE parameters","text":"<pre><code>//List all parameters\nint params = request-&gt;params();\nfor(int i=0;i&lt;params;i++){\n  AsyncWebParameter* p = request-&gt;getParam(i);\n  if(p-&gt;isFile()){ //p-&gt;isPost() is also true\n    Serial.printf(\"FILE[%s]: %s, size: %u\\n\", p-&gt;name().c_str(), p-&gt;value().c_str(), p-&gt;size());\n  } else if(p-&gt;isPost()){\n    Serial.printf(\"POST[%s]: %s\\n\", p-&gt;name().c_str(), p-&gt;value().c_str());\n  } else {\n    Serial.printf(\"GET[%s]: %s\\n\", p-&gt;name().c_str(), p-&gt;value().c_str());\n  }\n}\n\n//Check if GET parameter exists\nif(request-&gt;hasParam(\"download\"))\n  AsyncWebParameter* p = request-&gt;getParam(\"download\");\n\n//Check if POST (but not File) parameter exists\nif(request-&gt;hasParam(\"download\", true))\n  AsyncWebParameter* p = request-&gt;getParam(\"download\", true);\n\n//Check if FILE was uploaded\nif(request-&gt;hasParam(\"download\", true, true))\n  AsyncWebParameter* p = request-&gt;getParam(\"download\", true, true);\n\n//List all parameters (Compatibility)\nint args = request-&gt;args();\nfor(int i=0;i&lt;args;i++){\n  Serial.printf(\"ARG[%s]: %s\\n\", request-&gt;argName(i).c_str(), request-&gt;arg(i).c_str());\n}\n\n//Check if parameter exists (Compatibility)\nif(request-&gt;hasArg(\"download\"))\n  String arg = request-&gt;arg(\"download\");\n</code></pre> <p>See the Params example here.</p>"},{"location":"requests/#file-upload-handling","title":"FILE Upload handling","text":"<pre><code>void handleUpload(AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){\n  if(!index){\n    Serial.printf(\"UploadStart: %s\\n\", filename.c_str());\n  }\n  for(size_t i=0; i&lt;len; i++){\n    Serial.write(data[i]);\n  }\n  if(final){\n    Serial.printf(\"UploadEnd: %s, %u B\\n\", filename.c_str(), index+len);\n  }\n}\n</code></pre> <p>See the Upload example here.</p>"},{"location":"requests/#body-data-handling","title":"Body data handling","text":"<pre><code>void handleBody(AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total){\n  if(!index){\n    Serial.printf(\"BodyStart: %u B\\n\", total);\n  }\n  for(size_t i=0; i&lt;len; i++){\n    Serial.write(data[i]);\n  }\n  if(index + len == total){\n    Serial.printf(\"BodyEnd: %u B\\n\", total);\n  }\n}\n</code></pre> <p>If needed, the <code>_tempObject</code> field on the request can be used to store a pointer to temporary data (e.g. from the body) associated with the request. If assigned, the pointer will automatically be freed along with the request.</p>"},{"location":"requests/#json-body-handling-with-arduinojson","title":"JSON body handling with ArduinoJson","text":"<p>Endpoints which consume JSON can use a special handler to get ready to use JSON data in the request callback:</p> <pre><code>#include \"AsyncJson.h\"\n#include \"ArduinoJson.h\"\n\nAsyncCallbackJsonWebHandler* handler = new AsyncCallbackJsonWebHandler(\"/rest/endpoint\", [](AsyncWebServerRequest *request, JsonVariant &amp;json) {\n  JsonObject jsonObj = json.as&lt;JsonObject&gt;();\n  // ...\n});\nserver.addHandler(handler);\n</code></pre> <p>See the Json example here.</p>"},{"location":"requests/#messagepack-body-handling","title":"MessagePack body handling","text":"<p>Endpoints which consume MessagePack can use a special handler to get ready to use MessagePack data in the request callback:</p> <pre><code>#include \"AsyncMessagePack.h\"\n#include \"ArduinoJson.h\"\n\nAsyncCallbackMessagePackWebHandler* handler = new AsyncCallbackMessagePackWebHandler(\"/rest/endpoint\", [](AsyncWebServerRequest *request, JsonVariant &amp;json) {\n  JsonObject jsonObj = json.as&lt;JsonObject&gt;();\n  // ...\n});\nserver.addHandler(handler);\n</code></pre> <p>See the MessagePack example here.</p>"},{"location":"responses/","title":"Responses","text":""},{"location":"responses/#replace-a-response","title":"Replace a Response","text":"<pre><code>  // It is possible to replace a response.\n  // The previous one will be deleted.\n  // Response sending happens when the handler returns.\n  server.on(\"/replace\", HTTP_GET, [](AsyncWebServerRequest* request) {\n    request-&gt;send(200, \"text/plain\", \"Hello, world\");\n    // oups! finally we want to send a different response\n    request-&gt;send(400, \"text/plain\", \"validation error\");\n  });\n</code></pre> <p>This will send error 400 instead of 200.</p> <p>See the example here.</p>"},{"location":"responses/#request-continuation","title":"Request Continuation","text":"<p>Request Continuation is the ability to pause the processing of a request (the actual sending over the network) to be able to let another task commit the response on the network later.</p> <p>This is a common supported use case amongst web servers.</p> <p>A usage example can be found in the example called RequestContinuation.ino</p> <p>In the handler receiving the request, just execute:</p> <pre><code>AsyncWebServerRequestPtr ptr = request-&gt;pause();\n</code></pre> <p>This will pause the request and return a <code>AsyncWebServerRequestPtr</code> (this is a weak pointer).</p> <p>The AsyncWebServerRequestPtr is the ONLY object authorized to leave the scope of the request handler.</p> <p>Save somewhere this smart pointer and use it later to commit the response like this:</p> <pre><code>// you can check for expiration\nif (requestPtr.expired()) {\n  // the request connection was closed some time ago so the request is not accessible anymore\n\n} else if (longRunningTaskFinished) {\n  // this is what you always need to do when you want to access the request.\n  if (auto request = requestPtr.lock()) {\n    // send back the response\n    request-&gt;send(200, contentType, ...);\n\n  } else {\n    // the connection has been closed so the request is not accessible anymore\n  }\n}\n</code></pre> <p>Most of the time you can simply do like below if checking expiration is not needed:</p> <pre><code>if (auto request = requestPtr.lock()) {\n  // send back the response\n  request-&gt;send(200, contentType, ...);\n}\n</code></pre> <p>See the RequestContinuation example here and RequestContinuationComplete example here.</p>"},{"location":"responses/#responses_1","title":"Responses","text":""},{"location":"responses/#redirect-to-another-url","title":"Redirect to another URL","text":"<pre><code>//to local url\nrequest-&gt;redirect(\"/login\");\n\n//to external url\nrequest-&gt;redirect(\"http://esp8266.com\");\n</code></pre> <p>See the Redirect example here.</p>"},{"location":"responses/#basic-response-with-http-code","title":"Basic response with HTTP Code","text":"<pre><code>request-&gt;send(404); //Sends 404 File Not Found\n</code></pre>"},{"location":"responses/#basic-response-with-http-code-and-extra-headers","title":"Basic response with HTTP Code and extra headers","text":"<pre><code>AsyncWebServerResponse *response = request-&gt;beginResponse(404); //Sends 404 File Not Found\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"responses/#basic-response-with-string-content","title":"Basic response with string content","text":"<pre><code>request-&gt;send(200, \"text/plain\", \"Hello World!\");\n</code></pre>"},{"location":"responses/#basic-response-with-string-content-and-extra-headers","title":"Basic response with string content and extra headers","text":"<pre><code>AsyncWebServerResponse *response = request-&gt;beginResponse(200, \"text/plain\", \"Hello World!\");\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"responses/#send-large-webpage-from-progmem","title":"Send large webpage from PROGMEM","text":"<pre><code>const char index_html[] PROGMEM = \"...\"; // large char array, tested with 14k\nrequest-&gt;send_P(200, \"text/html\", index_html);\n</code></pre>"},{"location":"responses/#send-large-webpage-from-progmem-and-extra-headers","title":"Send large webpage from PROGMEM and extra headers","text":"<pre><code>const char index_html[] PROGMEM = \"...\"; // large char array, tested with 14k\nAsyncWebServerResponse *response = request-&gt;beginResponse_P(200, \"text/html\", index_html);\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"responses/#send-large-webpage-from-progmem-containing-templates","title":"Send large webpage from PROGMEM containing templates","text":"<pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\nconst char index_html[] PROGMEM = \"...\"; // large char array, tested with 14k\nrequest-&gt;send_P(200, \"text/html\", index_html, processor);\n</code></pre> <p>See the Templates example here.</p>"},{"location":"responses/#send-large-webpage-from-progmem-containing-templates-and-extra-headers","title":"Send large webpage from PROGMEM containing templates and extra headers","text":"<pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\nconst char index_html[] PROGMEM = \"...\"; // large char array, tested with 14k\nAsyncWebServerResponse *response = request-&gt;beginResponse_P(200, \"text/html\", index_html, processor);\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"responses/#send-binary-content-from-progmem","title":"Send binary content from PROGMEM","text":"<pre><code>//File: favicon.ico.gz, Size: 726\n#define favicon_ico_gz_len 726\nconst uint8_t favicon_ico_gz[] PROGMEM = {\n 0x1F, 0x8B, 0x08, 0x08, 0x0B, 0x87, 0x90, 0x57, 0x00, 0x03, 0x66, 0x61, 0x76, 0x69, 0x63, 0x6F,\n 0x6E, 0x2E, 0x69, 0x63, 0x6F, 0x00, 0xCD, 0x53, 0x5F, 0x48, 0x9A, 0x51, 0x14, 0xBF, 0x62, 0x6D,\n 0x86, 0x96, 0xA9, 0x64, 0xD3, 0xFE, 0xA8, 0x99, 0x65, 0x1A, 0xB4, 0x8A, 0xA8, 0x51, 0x54, 0x23,\n 0xA8, 0x11, 0x49, 0x51, 0x8A, 0x34, 0x62, 0x93, 0x85, 0x31, 0x58, 0x44, 0x12, 0x45, 0x2D, 0x58,\n 0xF5, 0x52, 0x41, 0x10, 0x23, 0x82, 0xA0, 0x20, 0x98, 0x2F, 0xC1, 0x26, 0xED, 0xA1, 0x20, 0x89,\n 0x04, 0xD7, 0x83, 0x58, 0x20, 0x28, 0x04, 0xAB, 0xD1, 0x9B, 0x8C, 0xE5, 0xC3, 0x60, 0x32, 0x64,\n 0x0E, 0x56, 0xBF, 0x9D, 0xEF, 0xF6, 0x30, 0x82, 0xED, 0xAD, 0x87, 0xDD, 0x8F, 0xF3, 0xDD, 0x8F,\n 0x73, 0xCF, 0xEF, 0x9C, 0xDF, 0x39, 0xBF, 0xFB, 0x31, 0x26, 0xA2, 0x27, 0x37, 0x97, 0xD1, 0x5B,\n 0xCF, 0x9E, 0x67, 0x30, 0xA6, 0x66, 0x8C, 0x99, 0xC9, 0xC8, 0x45, 0x9E, 0x6B, 0x3F, 0x5F, 0x74,\n 0xA6, 0x94, 0x5E, 0xDB, 0xFF, 0xB2, 0xE6, 0xE7, 0xE7, 0xF9, 0xDE, 0xD6, 0xD6, 0x96, 0xDB, 0xD8,\n 0xD8, 0x78, 0xBF, 0xA1, 0xA1, 0xC1, 0xDA, 0xDC, 0xDC, 0x2C, 0xEB, 0xED, 0xED, 0x15, 0x9B, 0xCD,\n 0xE6, 0x4A, 0x83, 0xC1, 0xE0, 0x2E, 0x29, 0x29, 0x99, 0xD6, 0x6A, 0xB5, 0x4F, 0x75, 0x3A, 0x9D,\n 0x61, 0x75, 0x75, 0x95, 0xB5, 0xB7, 0xB7, 0xDF, 0xC8, 0xD1, 0xD4, 0xD4, 0xF4, 0xB0, 0xBA, 0xBA,\n 0xFA, 0x83, 0xD5, 0x6A, 0xFD, 0x5A, 0x5E, 0x5E, 0x9E, 0x28, 0x2D, 0x2D, 0x0D, 0x10, 0xC6, 0x4B,\n 0x98, 0x78, 0x5E, 0x5E, 0xDE, 0x95, 0x42, 0xA1, 0x40, 0x4E, 0x4E, 0xCE, 0x65, 0x76, 0x76, 0xF6,\n 0x47, 0xB5, 0x5A, 0x6D, 0x4F, 0x26, 0x93, 0xA2, 0xD6, 0xD6, 0x56, 0x8E, 0x6D, 0x69, 0x69, 0xD1,\n 0x11, 0x36, 0x62, 0xB1, 0x58, 0x60, 0x32, 0x99, 0xA0, 0xD7, 0xEB, 0x51, 0x58, 0x58, 0x88, 0xFC,\n 0xFC, 0x7C, 0x10, 0x16, 0x02, 0x56, 0x2E, 0x97, 0x43, 0x2A, 0x95, 0x42, 0x2C, 0x16, 0x23, 0x33,\n 0x33, 0x33, 0xAE, 0x52, 0xA9, 0x1E, 0x64, 0x65, 0x65, 0x71, 0x7C, 0x7D, 0x7D, 0xBD, 0x93, 0xEA,\n 0xFE, 0x30, 0x1A, 0x8D, 0xE8, 0xEC, 0xEC, 0xC4, 0xE2, 0xE2, 0x22, 0x6A, 0x6A, 0x6A, 0x40, 0x39,\n 0x41, 0xB5, 0x38, 0x4E, 0xC8, 0x33, 0x3C, 0x3C, 0x0C, 0x87, 0xC3, 0xC1, 0x6B, 0x54, 0x54, 0x54,\n 0xBC, 0xE9, 0xEB, 0xEB, 0x93, 0x5F, 0x5C, 0x5C, 0x30, 0x8A, 0x9D, 0x2E, 0x2B, 0x2B, 0xBB, 0xA2,\n 0x3E, 0x41, 0xBD, 0x21, 0x1E, 0x8F, 0x63, 0x6A, 0x6A, 0x0A, 0x81, 0x40, 0x00, 0x94, 0x1B, 0x3D,\n 0x3D, 0x3D, 0x42, 0x3C, 0x96, 0x96, 0x96, 0x70, 0x7E, 0x7E, 0x8E, 0xE3, 0xE3, 0x63, 0xF8, 0xFD,\n 0xFE, 0xB4, 0xD7, 0xEB, 0xF5, 0x8F, 0x8F, 0x8F, 0x5B, 0x68, 0x5E, 0x6F, 0x05, 0xCE, 0xB4, 0xE3,\n 0xE8, 0xE8, 0x08, 0x27, 0x27, 0x27, 0xD8, 0xDF, 0xDF, 0xC7, 0xD9, 0xD9, 0x19, 0x6C, 0x36, 0x1B,\n 0x36, 0x36, 0x36, 0x38, 0x9F, 0x85, 0x85, 0x05, 0xAC, 0xAF, 0xAF, 0x23, 0x1A, 0x8D, 0x22, 0x91,\n 0x48, 0x20, 0x16, 0x8B, 0xFD, 0xDA, 0xDA, 0xDA, 0x7A, 0x41, 0x33, 0x7E, 0x57, 0x50, 0x50, 0x80,\n 0x89, 0x89, 0x09, 0x84, 0xC3, 0x61, 0x6C, 0x6F, 0x6F, 0x23, 0x12, 0x89, 0xE0, 0xE0, 0xE0, 0x00,\n 0x43, 0x43, 0x43, 0x58, 0x5E, 0x5E, 0xE6, 0x9C, 0x7D, 0x3E, 0x1F, 0x46, 0x47, 0x47, 0x79, 0xBE,\n 0xBD, 0xBD, 0x3D, 0xE1, 0x3C, 0x1D, 0x0C, 0x06, 0x9F, 0x10, 0xB7, 0xC7, 0x84, 0x4F, 0xF6, 0xF7,\n 0xF7, 0x63, 0x60, 0x60, 0x00, 0x83, 0x83, 0x83, 0x18, 0x19, 0x19, 0xC1, 0xDC, 0xDC, 0x1C, 0x8F,\n 0x17, 0x7C, 0xA4, 0x27, 0xE7, 0x34, 0x39, 0x39, 0x89, 0x9D, 0x9D, 0x1D, 0x6E, 0x54, 0xE3, 0x13,\n 0xE5, 0x34, 0x11, 0x37, 0x49, 0x51, 0x51, 0xD1, 0x4B, 0xA5, 0x52, 0xF9, 0x45, 0x26, 0x93, 0x5D,\n 0x0A, 0xF3, 0x92, 0x48, 0x24, 0xA0, 0x6F, 0x14, 0x17, 0x17, 0xA3, 0xB6, 0xB6, 0x16, 0x5D, 0x5D,\n 0x5D, 0x7C, 0x1E, 0xBB, 0xBB, 0xBB, 0x9C, 0xD7, 0xE1, 0xE1, 0x21, 0x42, 0xA1, 0xD0, 0x6B, 0xD2,\n 0x45, 0x4C, 0x33, 0x12, 0x34, 0xCC, 0xA0, 0x19, 0x54, 0x92, 0x56, 0x0E, 0xD2, 0xD9, 0x43, 0xF8,\n 0xCF, 0x82, 0x56, 0xC2, 0xDC, 0xEB, 0xEA, 0xEA, 0x38, 0x7E, 0x6C, 0x6C, 0x4C, 0xE0, 0xFE, 0x9D,\n 0xB8, 0xBF, 0xA7, 0xFA, 0xAF, 0x56, 0x56, 0x56, 0xEE, 0x6D, 0x6E, 0x6E, 0xDE, 0xB8, 0x47, 0x55,\n 0x55, 0x55, 0x6C, 0x66, 0x66, 0x46, 0x44, 0xDA, 0x3B, 0x34, 0x1A, 0x4D, 0x94, 0xB0, 0x3F, 0x09,\n 0x7B, 0x45, 0xBD, 0xA5, 0x5D, 0x2E, 0x57, 0x8C, 0x7A, 0x73, 0xD9, 0xED, 0xF6, 0x3B, 0x84, 0xFF,\n 0xE7, 0x7D, 0xA6, 0x3A, 0x2C, 0x95, 0x4A, 0xB1, 0x8E, 0x8E, 0x0E, 0x6D, 0x77, 0x77, 0xB7, 0xCD,\n 0xE9, 0x74, 0x3E, 0x73, 0xBB, 0xDD, 0x8F, 0x3C, 0x1E, 0x8F, 0xE6, 0xF4, 0xF4, 0x94, 0xAD, 0xAD,\n 0xAD, 0xDD, 0xDE, 0xCF, 0x73, 0x0B, 0x0B, 0xB8, 0xB6, 0xE0, 0x5D, 0xC6, 0x66, 0xC5, 0xE4, 0x10,\n 0x4C, 0xF4, 0xF7, 0xD8, 0x59, 0xF2, 0x7F, 0xA3, 0xB8, 0xB4, 0xFC, 0x0F, 0xEE, 0x37, 0x70, 0xEC,\n 0x16, 0x4A, 0x7E, 0x04, 0x00, 0x00\n};\n\nAsyncWebServerResponse *response = request-&gt;beginResponse_P(200, \"image/x-icon\", favicon_ico_gz, favicon_ico_gz_len);\nresponse-&gt;addHeader(\"Content-Encoding\", \"gzip\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"responses/#respond-with-content-coming-from-a-stream","title":"Respond with content coming from a Stream","text":"<pre><code>//read 12 bytes from Serial and send them as Content Type text/plain\nrequest-&gt;send(Serial, \"text/plain\", 12);\n</code></pre>"},{"location":"responses/#respond-with-content-coming-from-a-stream-and-extra-headers","title":"Respond with content coming from a Stream and extra headers","text":"<pre><code>//read 12 bytes from Serial and send them as Content Type text/plain\nAsyncWebServerResponse *response = request-&gt;beginResponse(Serial, \"text/plain\", 12);\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"responses/#respond-with-content-coming-from-a-stream-containing-templates","title":"Respond with content coming from a Stream containing templates","text":"<pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\n//read 12 bytes from Serial and send them as Content Type text/plain\nrequest-&gt;send(Serial, \"text/plain\", 12, processor);\n</code></pre>"},{"location":"responses/#respond-with-content-coming-from-a-stream-containing-templates-and-extra-headers","title":"Respond with content coming from a Stream containing templates and extra headers","text":"<pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\n//read 12 bytes from Serial and send them as Content Type text/plain\nAsyncWebServerResponse *response = request-&gt;beginResponse(Serial, \"text/plain\", 12, processor);\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"responses/#respond-with-content-coming-from-a-file","title":"Respond with content coming from a File","text":"<pre><code>//Send index.htm with default content type from SPIFFS\nrequest-&gt;send(SPIFFS, \"/index.htm\");\n\n//Send index.htm as text from SPIFFS\nrequest-&gt;send(SPIFFS, \"/index.htm\", \"text/plain\");\n\n//Download index.htm from SPIFFS\nrequest-&gt;send(SPIFFS, \"/index.htm\", String(), true);\n\n//Send index.htm with default content type from LittleFS\nrequest-&gt;send(LittleFS, \"/index.htm\");\n\n//Send index.htm as text from LittleFS\nrequest-&gt;send(LittleFS, \"/index.htm\", \"text/plain\");\n\n//Download index.htm from LittleFS\nrequest-&gt;send(LittleFS, \"/index.htm\", String(), true);\n</code></pre> <p>See the StaticFile example here.</p>"},{"location":"responses/#respond-with-content-coming-from-a-file-and-extra-headers","title":"Respond with content coming from a File and extra headers","text":"<pre><code>//Send index.htm with default content type from SPIFFS\nAsyncWebServerResponse *response = request-&gt;beginResponse(SPIFFS, \"/index.htm\");\n\n//Send index.htm as text from SPIFFS\nAsyncWebServerResponse *response = request-&gt;beginResponse(SPIFFS, \"/index.htm\", \"text/plain\");\n\n//Download index.htm from SPIFFS\nAsyncWebServerResponse *response = request-&gt;beginResponse(SPIFFS, \"/index.htm\", String(), true);\n\n//Send index.htm with default content type from LittleFS\nAsyncWebServerResponse *response = request-&gt;beginResponse(LittleFS, \"/index.htm\");\n\n//Send index.htm as text from LittleFS\nAsyncWebServerResponse *response = request-&gt;beginResponse(LittleFS, \"/index.htm\", \"text/plain\");\n\n//Download index.htm from LittleFS\nAsyncWebServerResponse *response = request-&gt;beginResponse(LittleFS, \"/index.htm\", String(), true);\n\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"responses/#respond-with-content-coming-from-a-file-containing-templates","title":"Respond with content coming from a File containing templates","text":"<p>Internally uses Chunked Response.</p> <p>Index.htm contents:</p> <pre><code>%HELLO_FROM_TEMPLATE%\n</code></pre> <p>Somewhere in source files:</p> <pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\n//Send index.htm with template processor function from SPIFFS\nrequest-&gt;send(SPIFFS, \"/index.htm\", String(), false, processor);\n\n//Send index.htm with template processor function from LittleFS\nrequest-&gt;send(LittleFS, \"/index.htm\", String(), false, processor);\n</code></pre>"},{"location":"responses/#respond-with-content-using-a-callback","title":"Respond with content using a callback","text":"<pre><code>//send 128 bytes as plain text\nrequest-&gt;send(\"text/plain\", 128, [](uint8_t *buffer, size_t maxLen, size_t index) -&gt; size_t {\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\n  //index equals the amount of bytes that have been already sent\n  //You will not be asked for more bytes once the content length has been reached.\n  //Keep in mind that you can not delay or yield waiting for more data!\n  //Send what you currently have and you will be asked for more again\n  return mySource.read(buffer, maxLen);\n});\n</code></pre> <p>See the ChunkResponse example here.</p>"},{"location":"responses/#respond-with-content-using-a-callback-and-extra-headers","title":"Respond with content using a callback and extra headers","text":"<pre><code>//send 128 bytes as plain text\nAsyncWebServerResponse *response = request-&gt;beginResponse(\"text/plain\", 128, [](uint8_t *buffer, size_t maxLen, size_t index) -&gt; size_t {\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\n  //index equals the amount of bytes that have been already sent\n  //You will not be asked for more bytes once the content length has been reached.\n  //Keep in mind that you can not delay or yield waiting for more data!\n  //Send what you currently have and you will be asked for more again\n  return mySource.read(buffer, maxLen);\n});\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"responses/#respond-with-file-content-using-a-callback-and-extra-headers","title":"Respond with file content using a callback and extra headers","text":"<p>With this code your ESP is able to serve even large (large in terms of ESP, e.g. 100kB) files without memory problems.</p> <p>You need to create a file handler in outer function (to have a single one for request) but use it in a lambda. The catch is that the lambda has it's own lifecycle which may/will cause it's called after the original function is over thus the original file handle is destroyed. Using the captured <code>&amp;file</code> in the lambda then causes segfault (Hello, Exception 9!) and the whole ESP crashes. By using this code, you tell the compiler to move the handle into the lambda so it won't be destroyed when outer function (that one where you call <code>request-&gt;send(response)</code>) ends.</p> <pre><code>// Example with SPIFFS\nconst File file = SPIFFS.open(path, \"r\");\n\nconst contentType = \"application/javascript\";\n\nAsyncWebServerResponse *response = request-&gt;beginResponse(\n  contentType,\n  file.size(),\n  [file](uint8_t *buffer, size_t maxLen, size_t total) mutable -&gt; size_t {\n     int bytes = file.read(buffer, maxLen);\n\n     // close file at the end\n     if (bytes + total == file.size()) file.close();\n\n     return max(0, bytes); // return 0 even when no bytes were loaded\n   }\n);\n\nif (gzipped) {\n  response-&gt;addHeader(F(\"Content-Encoding\"), F(\"gzip\"));\n}\n\nrequest-&gt;send(response);\n</code></pre> <pre><code>// Example with LittleFS\nconst File file = LittleFS.open(path, \"r\");\n\nconst contentType = \"application/javascript\";\n\nAsyncWebServerResponse *response = request-&gt;beginResponse(\n  contentType,\n  file.size(),\n  [file](uint8_t *buffer, size_t maxLen, size_t total) mutable -&gt; size_t {\n     int bytes = file.read(buffer, maxLen);\n\n     // close file at the end\n     if (bytes + total == file.size()) file.close();\n\n     return max(0, bytes); // return 0 even when no bytes were loaded\n   }\n);\n\nif (gzipped) {\n  response-&gt;addHeader(F(\"Content-Encoding\"), F(\"gzip\"));\n}\n\nrequest-&gt;send(response);\n</code></pre>"},{"location":"responses/#respond-with-content-using-a-callback-containing-templates","title":"Respond with content using a callback containing templates","text":"<pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\n//send 128 bytes as plain text\nrequest-&gt;send(\"text/plain\", 128, [](uint8_t *buffer, size_t maxLen, size_t index) -&gt; size_t {\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\n  //index equals the amount of bytes that have been already sent\n  //You will not be asked for more bytes once the content length has been reached.\n  //Keep in mind that you can not delay or yield waiting for more data!\n  //Send what you currently have and you will be asked for more again\n  return mySource.read(buffer, maxLen);\n}, processor);\n</code></pre>"},{"location":"responses/#respond-with-content-using-a-callback-containing-templates-and-extra-headers","title":"Respond with content using a callback containing templates and extra headers","text":"<pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\n//send 128 bytes as plain text\nAsyncWebServerResponse *response = request-&gt;beginResponse(\"text/plain\", 128, [](uint8_t *buffer, size_t maxLen, size_t index) -&gt; size_t {\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\n  //index equals the amount of bytes that have been already sent\n  //You will not be asked for more bytes once the content length has been reached.\n  //Keep in mind that you can not delay or yield waiting for more data!\n  //Send what you currently have and you will be asked for more again\n  return mySource.read(buffer, maxLen);\n}, processor);\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"responses/#chunked-response","title":"Chunked Response","text":"<p>Used when content length is unknown. Works best if the client supports HTTP/1.1</p> <pre><code>AsyncWebServerResponse *response = request-&gt;beginChunkedResponse(\"text/plain\", [](uint8_t *buffer, size_t maxLen, size_t index) -&gt; size_t {\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\n  //index equals the amount of bytes that have been already sent\n  //You will be asked for more data until 0 is returned\n  //Keep in mind that you can not delay or yield waiting for more data!\n  return mySource.read(buffer, maxLen);\n});\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre> <p>See the ChunkRequest example here and ChunkRetryResponse example here.</p>"},{"location":"responses/#chunked-response-containing-templates","title":"Chunked Response containing templates","text":"<p>Used when content length is unknown. Works best if the client supports HTTP/1.1</p> <pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\nAsyncWebServerResponse *response = request-&gt;beginChunkedResponse(\"text/plain\", [](uint8_t *buffer, size_t maxLen, size_t index) -&gt; size_t {\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\n  //index equals the amount of bytes that have been already sent\n  //You will be asked for more data until 0 is returned\n  //Keep in mind that you can not delay or yield waiting for more data!\n  return mySource.read(buffer, maxLen);\n}, processor);\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"responses/#print-to-response","title":"Print to response","text":"<pre><code>AsyncResponseStream *response = request-&gt;beginResponseStream(\"text/html\");\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nresponse-&gt;printf(\"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Webpage at %s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\", request-&gt;url().c_str());\n\nresponse-&gt;print(\"&lt;h2&gt;Hello \");\nresponse-&gt;print(request-&gt;client()-&gt;remoteIP());\nresponse-&gt;print(\"&lt;/h2&gt;\");\n\nresponse-&gt;print(\"&lt;h3&gt;General&lt;/h3&gt;\");\nresponse-&gt;print(\"&lt;ul&gt;\");\nresponse-&gt;printf(\"&lt;li&gt;Version: HTTP/1.%u&lt;/li&gt;\", request-&gt;version());\nresponse-&gt;printf(\"&lt;li&gt;Method: %s&lt;/li&gt;\", request-&gt;methodToString());\nresponse-&gt;printf(\"&lt;li&gt;URL: %s&lt;/li&gt;\", request-&gt;url().c_str());\nresponse-&gt;printf(\"&lt;li&gt;Host: %s&lt;/li&gt;\", request-&gt;host().c_str());\nresponse-&gt;printf(\"&lt;li&gt;ContentType: %s&lt;/li&gt;\", request-&gt;contentType().c_str());\nresponse-&gt;printf(\"&lt;li&gt;ContentLength: %u&lt;/li&gt;\", request-&gt;contentLength());\nresponse-&gt;printf(\"&lt;li&gt;Multipart: %s&lt;/li&gt;\", request-&gt;multipart()?\"true\":\"false\");\nresponse-&gt;print(\"&lt;/ul&gt;\");\n\nresponse-&gt;print(\"&lt;h3&gt;Headers&lt;/h3&gt;\");\nresponse-&gt;print(\"&lt;ul&gt;\");\nint headers = request-&gt;headers();\nfor(int i=0;i&lt;headers;i++){\n  AsyncWebHeader* h = request-&gt;getHeader(i);\n  response-&gt;printf(\"&lt;li&gt;%s: %s&lt;/li&gt;\", h-&gt;name().c_str(), h-&gt;value().c_str());\n}\nresponse-&gt;print(\"&lt;/ul&gt;\");\n\nresponse-&gt;print(\"&lt;h3&gt;Parameters&lt;/h3&gt;\");\nresponse-&gt;print(\"&lt;ul&gt;\");\nint params = request-&gt;params();\nfor(int i=0;i&lt;params;i++){\n  AsyncWebParameter* p = request-&gt;getParam(i);\n  if(p-&gt;isFile()){\n    response-&gt;printf(\"&lt;li&gt;FILE[%s]: %s, size: %u&lt;/li&gt;\", p-&gt;name().c_str(), p-&gt;value().c_str(), p-&gt;size());\n  } else if(p-&gt;isPost()){\n    response-&gt;printf(\"&lt;li&gt;POST[%s]: %s&lt;/li&gt;\", p-&gt;name().c_str(), p-&gt;value().c_str());\n  } else {\n    response-&gt;printf(\"&lt;li&gt;GET[%s]: %s&lt;/li&gt;\", p-&gt;name().c_str(), p-&gt;value().c_str());\n  }\n}\nresponse-&gt;print(\"&lt;/ul&gt;\");\n\nresponse-&gt;print(\"&lt;/body&gt;&lt;/html&gt;\");\n//send the response last\nrequest-&gt;send(response);\n</code></pre> <p>See the AsyncResponseStream example here.</p>"},{"location":"responses/#arduinojson-basic-response","title":"ArduinoJson Basic Response","text":"<p>This way of sending Json is great for when the result is below 4KB</p> <pre><code>#include \"AsyncJson.h\"\n#include \"ArduinoJson.h\"\n\nAsyncResponseStream *response = request-&gt;beginResponseStream(\"application/json\");\nJsonDocument doc;\ndoc[\"heap\"] = ESP.getFreeHeap();\ndoc[\"ssid\"] = WiFi.SSID();\nserializeJson(doc, *response);\nrequest-&gt;send(response);\n</code></pre>"},{"location":"responses/#arduinojson-advanced-response","title":"ArduinoJson Advanced Response","text":"<p>This response can handle really large Json objects (tested to 40KB) There isn't any noticeable speed decrease for small results with the method above Since ArduinoJson does not allow reading parts of the string, the whole Json has to be passed every time a chunks needs to be sent, which shows speed decrease proportional to the resulting json packets</p> <pre><code>#include \"AsyncJson.h\"\n#include \"ArduinoJson.h\"\n\nAsyncJsonResponse * response = new AsyncJsonResponse();\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nJsonDocument&amp; doc = response-&gt;getRoot();\ndoc[\"heap\"] = ESP.getFreeHeap();\ndoc[\"ssid\"] = WiFi.SSID();\nresponse-&gt;setLength();\nrequest-&gt;send(response);\n</code></pre> <p>See the Json example here.</p>"},{"location":"responses/#messagepack-response","title":"MessagePack Response","text":"<p>MessagePack is a binary serialization format that is more compact than JSON.</p> <pre><code>#include \"AsyncMessagePack.h\"\n#include \"ArduinoJson.h\"\n\nAsyncMessagePackResponse * response = new AsyncMessagePackResponse();\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nJsonDocument&amp; doc = response-&gt;getRoot();\ndoc[\"heap\"] = ESP.getFreeHeap();\ndoc[\"ssid\"] = WiFi.SSID();\nresponse-&gt;setLength();\nrequest-&gt;send(response);\n</code></pre> <p>See the MessagePack example here.</p>"},{"location":"responses/#adding-default-headers","title":"Adding Default Headers","text":"<p>In some cases, such as when working with CORS, or with some sort of custom authentication system, you might need to define a header that should get added to all responses (including static, websocket and EventSource). The DefaultHeaders singleton allows you to do this.</p> <p>Example:</p> <pre><code>DefaultHeaders::Instance().addHeader(\"Access-Control-Allow-Origin\", \"*\");\nwebServer.begin();\n</code></pre> <p>NOTE: You will still need to respond to the OPTIONS method for CORS pre-flight in most cases. (unless you are only using GET)</p> <p>This is one option:</p> <pre><code>webServer.onNotFound([](AsyncWebServerRequest *request) {\n  if (request-&gt;method() == HTTP_OPTIONS) {\n    request-&gt;send(200);\n  } else {\n    request-&gt;send(404);\n  }\n});\n</code></pre> <p>See the CORS example here.</p>"},{"location":"responses/#bad-responses","title":"Bad Responses","text":"<p>Some responses are implemented, but you should not use them, because they do not conform to HTTP. The following example will lead to unclean close of the connection and more time wasted than providing the length of the content</p>"},{"location":"responses/#respond-with-content-using-a-callback-without-content-length-to-http10-clients","title":"Respond with content using a callback without content length to HTTP/1.0 clients","text":"<pre><code>//This is used as fallback for chunked responses to HTTP/1.0 Clients\nrequest-&gt;send(\"text/plain\", 0, [](uint8_t *buffer, size_t maxLen, size_t index) -&gt; size_t {\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\n  //You will be asked for more data until 0 is returned\n  //Keep in mind that you can not delay or yield waiting for more data!\n  return mySource.read(buffer, maxLen);\n});\n</code></pre>"},{"location":"routing/","title":"Routing","text":""},{"location":"routing/#url-matching-and-routing","title":"URL Matching and Routing","text":"<p>The <code>AsyncURIMatcher</code> class provides flexible and powerful URL routing mechanisms.</p> <p>Important: When using plain strings (not <code>AsyncURIMatcher</code> objects), the library uses auto-detection (<code>URIMatchAuto</code>) which analyzes the URI pattern and applies appropriate matching rules. This is not simple exact matching - it combines exact and folder matching by default!</p>"},{"location":"routing/#auto-detection-behavior","title":"Auto-Detection Behavior","text":"<p>When you pass a plain string or <code>const char*</code> to <code>server.on()</code>, the <code>URIMatchAuto</code> flag is used, which:</p> <ol> <li>Empty URI: Matches everything</li> <li>Ends with <code>*</code>: Becomes prefix match (<code>URIMatchPrefix</code>)</li> <li>Contains <code>/*.ext</code>: Becomes extension match (<code>URIMatchExtension</code>)</li> <li>Starts with <code>^</code> and ends with <code>$</code>: Becomes regex match (if regex enabled)</li> <li>Everything else: Becomes both exact and folder match (<code>URIMatchPrefixFolder | URIMatchExact</code>)</li> </ol> <p>This means traditional string-based routes like <code>server.on(\"/path\", handler)</code> will match:</p> <ul> <li><code>/path</code> (exact match)</li> <li><code>/path/</code> (folder with trailing slash)</li> <li><code>/path/anything</code> (folder match)</li> </ul> <p>But will NOT match <code>/path-suffix</code> (prefix without folder separator).</p>"},{"location":"routing/#usage-patterns","title":"Usage Patterns","text":""},{"location":"routing/#traditional-string-based-routing-auto-detection","title":"Traditional String-based Routing (Auto-Detection)","text":"<pre><code>// Auto-detection with exact + folder matching\nserver.on(\"/api\", handler);          // Matches /api AND /api/anything\nserver.on(\"/login\", handler);        // Matches /login AND /login/sub\n\n// Auto-detection with prefix matching\nserver.on(\"/prefix*\", handler);      // Matches /prefix, /prefix-test, /prefix/sub\n\n// Auto-detection with extension matching\nserver.on(\"/images/*.jpg\", handler); // Matches /images/pic.jpg, /images/sub/pic.jpg\n</code></pre>"},{"location":"routing/#factory-functions","title":"Factory Functions","text":"<p>Using factory functions is clearer and gives you explicit control over matching behavior.</p> <pre><code>// Exact matching only (matches \"/login\" but NOT \"/login/sub\")\nserver.on(AsyncURIMatcher::exact(\"/login\"), handler);\n\n// Prefix matching (matches \"/api\", \"/api/v1\", \"/api-test\")\nserver.on(AsyncURIMatcher::prefix(\"/api\"), handler);\n\n// Directory matching (matches \"/admin/users\" but NOT \"/admin\")\n// Requires trailing slash in URL conceptually\nserver.on(AsyncURIMatcher::dir(\"/admin\"), handler);\n\n// Extension matching\nserver.on(AsyncURIMatcher::ext(\"/images/*.jpg\"), handler);\n\n// Case insensitive matching\nserver.on(AsyncURIMatcher::exact(\"/case\", AsyncURIMatcher::CaseInsensitive), handler);\n// matches \"/case\", \"/CASE\", \"/CaSe\"\n\n// Regular Expression (requires -D ASYNCWEBSERVER_REGEX)\n#ifdef ASYNCWEBSERVER_REGEX\nserver.on(AsyncURIMatcher::regex(\"^/user/([0-9]+)$\"), handler);\n#endif\n</code></pre>"},{"location":"routing/#param-rewrite-with-matching","title":"Param Rewrite With Matching","text":"<p>It is possible to rewrite the request url with parameter match. Here is an example with one parameter: Rewrite for example \"/radio/{frequence}\" -&gt; \"/radio?f={frequence}\"</p> <pre><code>class OneParamRewrite : public AsyncWebRewrite\n{\n  protected:\n    String _urlPrefix;\n    int _paramIndex;\n    String _paramsBackup;\n\n  public:\n  OneParamRewrite(const char* from, const char* to)\n    : AsyncWebRewrite(from, to) {\n\n      _paramIndex = _from.indexOf('{');\n\n      if( _paramIndex &gt;=0 &amp;&amp; _from.endsWith(\"}\")) {\n        _urlPrefix = _from.substring(0, _paramIndex);\n        int index = _params.indexOf('{');\n        if(index &gt;= 0) {\n          _params = _params.substring(0, index);\n        }\n      } else {\n        _urlPrefix = _from;\n      }\n      _paramsBackup = _params;\n  }\n\n  bool match(AsyncWebServerRequest *request) override {\n    if(request-&gt;url().startsWith(_urlPrefix)) {\n      if(_paramIndex &gt;= 0) {\n        _params = _paramsBackup + request-&gt;url().substring(_paramIndex);\n      } else {\n        _params = _paramsBackup;\n      }\n    return true;\n\n    } else {\n      return false;\n    }\n  }\n};\n</code></pre> <p>Usage:</p> <pre><code>  server.addRewrite( new OneParamRewrite(\"/radio/{frequence}\", \"/radio?f={frequence}\") );\n</code></pre> <p>See the Rewrite example here.</p>"},{"location":"routing/#remove-handlers-and-rewrites","title":"Remove handlers and rewrites","text":"<p>Server goes through handlers in same order as they were added. You can't simple add handler with same path to override them. To remove handler:</p> <pre><code>// save callback for particular URL path\nauto&amp; handler = server.on(\"/some/path\", [](AsyncWebServerRequest *request){\n  //do something useful\n});\n// when you don't need handler anymore remove it\nserver.removeHandler(&amp;handler);\n\n// same with rewrites\nserver.removeRewrite(&amp;someRewrite);\n\nserver.onNotFound([](AsyncWebServerRequest *request){\n  request-&gt;send(404);\n});\n\n// remove server.onNotFound handler\nserver.onNotFound(NULL);\n\n// remove all rewrites, handlers and onNotFound/onFileUpload/onRequestBody callbacks\nserver.reset();\n</code></pre>"},{"location":"setup/","title":"Server Setup","text":""},{"location":"setup/#setting-up-the-server","title":"Setting up the server","text":"<pre><code>#include &lt;Arduino.h&gt;\n#if defined(ESP32) || defined(LIBRETINY)\n#include &lt;AsyncTCP.h&gt;\n#include &lt;WiFi.h&gt;\n#elif defined(ESP8266)\n#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESPAsyncTCP.h&gt;\n#elif defined(TARGET_RP2040) || defined(TARGET_RP2350) || defined(PICO_RP2040) || defined(PICO_RP2350)\n#include &lt;RPAsyncTCP.h&gt;\n#include &lt;WiFi.h&gt;\n#endif\n\n#include &lt;ESPAsyncWebServer.h&gt;\n\nAsyncWebServer server(80);\nAsyncWebSocket ws(\"/ws\"); // access at ws://[esp ip]/ws\nAsyncEventSource events(\"/events\"); // event source (Server-Sent events)\n\nconst char* ssid = \"your-ssid\";\nconst char* password = \"your-pass\";\n\n//flag to use from web update to reboot the ESP\nbool shouldReboot = false;\n\nvoid onRequest(AsyncWebServerRequest *request){\n  //Handle Unknown Request\n  request-&gt;send(404);\n}\n\nvoid onBody(AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total){\n  //Handle body\n}\n\nvoid onUpload(AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){\n  //Handle upload\n}\n\nvoid onEvent(AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len){\n  //Handle WebSocket event\n}\n\nvoid setup(){\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  if (WiFi.waitForConnectResult() != WL_CONNECTED) {\n    Serial.printf(\"WiFi Failed!\\n\");\n    return;\n  }\n\n  // attach AsyncWebSocket\n  ws.onEvent(onEvent);\n  server.addHandler(&amp;ws);\n\n  // attach AsyncEventSource\n  server.addHandler(&amp;events);\n\n  // respond to GET requests on URL /heap\n  server.on(\"/heap\", HTTP_GET, [](AsyncWebServerRequest *request){\n    request-&gt;send(200, \"text/plain\", String(ESP.getFreeHeap()));\n  });\n\n  // upload a file to /upload\n  server.on(\"/upload\", HTTP_POST, [](AsyncWebServerRequest *request){\n    request-&gt;send(200);\n  }, onUpload);\n\n  // send a file when /index is requested (SPIFFS example)\n  server.on(\"/index\", HTTP_ANY, [](AsyncWebServerRequest *request){\n    request-&gt;send(SPIFFS, \"/index.htm\");\n  });\n\n  // send a file when /index is requested (LittleFS example)\n  server.on(\"/index\", HTTP_ANY, [](AsyncWebServerRequest *request){\n    request-&gt;send(LittleFS, \"/index.htm\");\n  });\n\n  // Simple Firmware Update Form\n  server.on(\"/update\", HTTP_GET, [](AsyncWebServerRequest *request){\n    request-&gt;send(200, \"text/html\", \"&lt;form method='POST' action='/update' enctype='multipart/form-data'&gt;&lt;input type='file' name='update'&gt;&lt;input type='submit' value='Update'&gt;&lt;/form&gt;\");\n  });\n  server.on(\"/update\", HTTP_POST, [](AsyncWebServerRequest *request){\n    shouldReboot = !Update.hasError();\n    AsyncWebServerResponse *response = request-&gt;beginResponse(200, \"text/plain\", shouldReboot?\"OK\":\"FAIL\");\n    response-&gt;addHeader(\"Connection\", \"close\");\n    request-&gt;send(response);\n  },[](AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){\n    if(!index){\n      Serial.printf(\"Update Start: %s\\n\", filename.c_str());\n      Update.runAsync(true);\n      if(!Update.begin((ESP.getFreeSketchSpace() - 0x1000) &amp; 0xFFFFF000)){\n        Update.printError(Serial);\n      }\n    }\n    if(!Update.hasError()){\n      if(Update.write(data, len) != len){\n        Update.printError(Serial);\n      }\n    }\n    if(final){\n      if(Update.end(true)){\n        Serial.printf(\"Update Success: %uB\\n\", index+len);\n      } else {\n        Update.printError(Serial);\n      }\n    }\n  });\n\n  // attach filesystem root at URL /fs (SPIFFS example)\n  server.serveStatic(\"/fs\", SPIFFS, \"/\");\n\n  // attach filesystem root at URL /fs (LittleFS example)\n  server.serveStatic(\"/fs\", LittleFS, \"/\");\n\n  // Catch-All Handlers\n  // Any request that can not find a Handler that canHandle it\n  // ends in the callbacks below.\n  server.onNotFound(onRequest);\n  server.onFileUpload(onUpload);\n  server.onRequestBody(onBody);\n\n  server.begin();\n}\n\nvoid loop(){\n  if(shouldReboot){\n    Serial.println(\"Rebooting...\");\n    delay(100);\n    ESP.restart();\n  }\n  static char temp[128];\n  sprintf(temp, \"Seconds since boot: %u\", millis()/1000);\n  events.send(temp, \"time\"); //send event \"time\"\n}\n</code></pre> <p>IMPORTANT: Authentication should now use <code>AsyncAuthenticationMiddleware</code> instead of the deprecated methods. See the Authentication with AsyncAuthenticationMiddleware section.</p>"},{"location":"setup/#setup-global-and-class-functions-as-request-handlers","title":"Setup global and class functions as request handlers","text":"<pre><code>#include &lt;Arduino.h&gt;\n#include &lt;ESPAsyncWebserver.h&gt;\n#include &lt;Hash.h&gt;\n#include &lt;functional&gt;\n\nvoid handleRequest(AsyncWebServerRequest *request){}\n\nclass WebClass {\npublic :\n  AsyncWebServer classWebServer = AsyncWebServer(81);\n\n  WebClass(){};\n\n  void classRequest (AsyncWebServerRequest *request){}\n\n  void begin(){\n    // attach global request handler\n    classWebServer.on(\"/example\", HTTP_ANY, handleRequest);\n\n    // attach class request handler\n    classWebServer.on(\"/example\", HTTP_ANY, std::bind(&amp;WebClass::classRequest, this, std::placeholders::_1));\n  }\n};\n\nAsyncWebServer globalWebServer(80);\nWebClass webClassInstance;\n\nvoid setup() {\n  // attach global request handler\n  globalWebServer.on(\"/example\", HTTP_ANY, handleRequest);\n\n  // attach class request handler\n  globalWebServer.on(\"/example\", HTTP_ANY, std::bind(&amp;WebClass::classRequest, webClassInstance, std::placeholders::_1));\n}\n\nvoid loop() {\n\n}\n</code></pre>"},{"location":"setup/#methods-for-controlling-websocket-connections","title":"Methods for controlling websocket connections","text":"<pre><code>  // Disable client connections if it was activated\n  if ( ws.enabled() )\n    ws.enable(false);\n\n  // enable client connections if it was disabled\n  if ( !ws.enabled() )\n    ws.enable(true);\n</code></pre>"},{"location":"static-files/","title":"Static Files","text":""},{"location":"static-files/#serving-static-files","title":"Serving static files","text":"<p>In addition to serving files from SPIFFS / LittleFS as described above, the server provide a dedicated handler that optimize the performance of serving files from SPIFFS / LittleFS - <code>AsyncStaticWebHandler</code>. Use <code>server.serveStatic()</code> function to initialize and add a new instance of <code>AsyncStaticWebHandler</code> to the server. The Handler will not handle the request if the file does not exists, e.g. the server will continue to look for another handler that can handle the request. Notice that you can chain setter functions to setup the handler, or keep a pointer to change it at a later time.</p>"},{"location":"static-files/#serving-specific-file-by-name","title":"Serving specific file by name","text":"<pre><code>// Serve the file \"/www/page.htm\" when request url is \"/page.htm\" from SPIFFS\nserver.serveStatic(\"/page.htm\", SPIFFS, \"/www/page.htm\");\n\n// Serve the file \"/www/page.htm\" when request url is \"/page.htm\" from LittleFS\nserver.serveStatic(\"/page.htm\", LittleFS, \"/www/page.htm\");\n</code></pre>"},{"location":"static-files/#serving-files-in-directory","title":"Serving files in directory","text":"<p>To serve files in a directory, the path to the files should specify a directory in SPIFFS / LittleFS and ends with \"/\".</p> <pre><code>// Serve files in directory \"/www/\" when request url starts with \"/\" from SPIFFS\n// Request to the root or none existing files will try to server the default\n// file name \"index.htm\" if exists\nserver.serveStatic(\"/\", SPIFFS, \"/www/\");\n\n// Server with different default file from SPIFFS\nserver.serveStatic(\"/\", SPIFFS, \"/www/\").setDefaultFile(\"default.html\");\n\n// Serve files in directory \"/www/\" when request url starts with \"/\" from LittleFS\n// Request to the root or none existing files will try to server the default\n// file name \"index.htm\" if exists\nserver.serveStatic(\"/\", LittleFS, \"/www/\");\n\n// Server with different default file from LittleFS\nserver.serveStatic(\"/\", LittleFS, \"/www/\").setDefaultFile(\"default.html\");\n</code></pre>"},{"location":"static-files/#serving-static-files-with-authentication","title":"Serving static files with authentication","text":"<p>IMPORTANT: Use <code>AsyncAuthenticationMiddleware</code> instead of the deprecated <code>setAuthentication()</code> method.</p> <pre><code>AsyncAuthenticationMiddleware authMiddleware;\nauthMiddleware.setAuthType(AsyncAuthType::AUTH_DIGEST);\nauthMiddleware.setRealm(\"My app name\");\nauthMiddleware.setUsername(\"admin\");\nauthMiddleware.setPassword(\"admin\");\nauthMiddleware.generateHash();\n\n// For SPIFFS\nserver\n    .serveStatic(\"/\", SPIFFS, \"/www/\")\n    .setDefaultFile(\"default.html\")\n    .addMiddleware(&amp;authMiddleware);\n\n// For LittleFS\nserver\n    .serveStatic(\"/\", LittleFS, \"/www/\")\n    .setDefaultFile(\"default.html\")\n    .addMiddleware(&amp;authMiddleware);\n</code></pre>"},{"location":"static-files/#specifying-cache-control-header","title":"Specifying Cache-Control header","text":"<p>It is possible to specify Cache-Control header value to reduce the number of calls to the server once the client loaded the files. For more information on Cache-Control values see Cache-Control</p> <pre><code>// Cache responses for 10 minutes (600 seconds) from SPIFFS\nserver.serveStatic(\"/\", SPIFFS, \"/www/\").setCacheControl(\"max-age=600\");\n\n// Cache responses for 10 minutes (600 seconds) from LittleFS\nserver.serveStatic(\"/\", LittleFS, \"/www/\").setCacheControl(\"max-age=600\");\n\n//*** Change Cache-Control after server setup ***\n\n// During setup - keep a pointer to the handler (SPIFFS)\nAsyncStaticWebHandler* handler = &amp;server.serveStatic(\"/\", SPIFFS, \"/www/\").setCacheControl(\"max-age=600\");\n\n// During setup - keep a pointer to the handler (LittleFS)\nAsyncStaticWebHandler* handler = &amp;server.serveStatic(\"/\", LittleFS, \"/www/\").setCacheControl(\"max-age=600\");\n\n// At a later event - change Cache-Control\nhandler-&gt;setCacheControl(\"max-age=30\");\n</code></pre>"},{"location":"static-files/#specifying-date-modified-header","title":"Specifying Date-Modified header","text":"<p>It is possible to specify Date-Modified header to enable the server to return Not-Modified (304) response for requests with \"If-Modified-Since\" header with the same value, instead of responding with the actual file content.</p> <pre><code>// Update the date modified string every time files are updated (SPIFFS)\nserver.serveStatic(\"/\", SPIFFS, \"/www/\").setLastModified(\"Mon, 20 Jun 2016 14:00:00 GMT\");\n\n// Update the date modified string every time files are updated (LittleFS)\nserver.serveStatic(\"/\", LittleFS, \"/www/\").setLastModified(\"Mon, 20 Jun 2016 14:00:00 GMT\");\n\n//*** Change last modified value at a later stage ***\n\n// During setup - read last modified value from config or EEPROM (SPIFFS)\nString date_modified = loadDateModified();\nAsyncStaticWebHandler* handler = &amp;server.serveStatic(\"/\", SPIFFS, \"/www/\");\nhandler-&gt;setLastModified(date_modified);\n\n// During setup - read last modified value from config or EEPROM (LittleFS)\nString date_modified = loadDateModified();\nAsyncStaticWebHandler* handler = &amp;server.serveStatic(\"/\", LittleFS, \"/www/\");\nhandler-&gt;setLastModified(date_modified);\n\n// At a later event when files are updated\nString date_modified = getNewDateModfied();\nsaveDateModified(date_modified); // Save for next reset\nhandler-&gt;setLastModified(date_modified);\n</code></pre>"},{"location":"static-files/#specifying-template-processor-callback","title":"Specifying Template Processor callback","text":"<p>It is possible to specify template processor for static files. For information on template processor see Respond with content coming from a File containing templates.</p> <pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\n// For SPIFFS\nserver.serveStatic(\"/\", SPIFFS, \"/www/\").setTemplateProcessor(processor);\n\n// For LittleFS\nserver.serveStatic(\"/\", LittleFS, \"/www/\").setTemplateProcessor(processor);\n</code></pre>"},{"location":"static-files/#serving-static-files-by-custom-handling","title":"Serving static files by custom handling","text":"<p>It may happen your static files are too big and the ESP will crash the request before it sends the whole file. In that case, you can handle static files with custom file serving through not found handler.</p> <p>This code below is more-or-less equivalent to this:</p> <pre><code>webServer.serveStatic(\"/\", SPIFFS, STATIC_FILES_PREFIX).setDefaultFile(\"index.html\")\n// or\nwebServer.serveStatic(\"/\", LittleFS, STATIC_FILES_PREFIX).setDefaultFile(\"index.html\")\n</code></pre> <p>First, declare the handling function:</p> <pre><code>bool handleStaticFile(AsyncWebServerRequest *request) {\n  String path = STATIC_FILES_PREFIX + request-&gt;url();\n\n  if (path.endsWith(\"/\")) path += F(\"index.html\");\n\n  String contentType = getContentType(path);\n  String pathWithGz = path + \".gz\";\n\n  // Try SPIFFS first\n  if (SPIFFS.exists(pathWithGz) || SPIFFS.exists(path)) {\n    bool gzipped = false;\n    if (SPIFFS.exists(pathWithGz)) {\n        gzipped = true;\n        path += \".gz\";\n    }\n\n    // TODO serve the file\n\n    return true;\n  }\n\n  // Try LittleFS if SPIFFS fails\n  if (LittleFS.exists(pathWithGz) || LittleFS.exists(path)) {\n    bool gzipped = false;\n    if (LittleFS.exists(pathWithGz)) {\n        gzipped = true;\n        path += \".gz\";\n    }\n\n    // TODO serve the file\n\n    return true;\n  }\n\n  return false;\n}\n</code></pre> <p>And then configure your webserver:</p> <pre><code>webServer.onNotFound([](AsyncWebServerRequest *request) {\n  if (handleStaticFile(request)) return;\n\n  request-&gt;send(404);\n});\n</code></pre> <p>You may want to try Respond with file content using a callback and extra headers For actual serving the file.</p>"},{"location":"websockets/","title":"WebSockets","text":""},{"location":"websockets/#asyncwebsocketmessagebuffer-and-makebuffer","title":"<code>AsyncWebSocketMessageBuffer</code> and <code>makeBuffer()</code>","text":"<p>The fork from yubox-node-org introduces some breaking API changes compared to the original library, especially regarding the use of <code>std::shared_ptr&lt;std::vector&lt;uint8_t&gt;&gt;</code> for WebSocket.</p> <p>This library is compatible with the original library from me-no-dev regarding WebSocket, and wraps the optimizations done by <code>yubox-node-org</code> in the <code>AsyncWebSocketMessageBuffer</code> class. So you have the choice of which API to use.</p> <p>Here are examples for serializing a Json document in a websocket message buffer:</p> <pre><code>void send(JsonDocument&amp; doc) {\n  const size_t len = measureJson(doc);\n\n  // original API from me-no-dev\n  AsyncWebSocketMessageBuffer* buffer = _ws-&gt;makeBuffer(len);\n  assert(buffer); // up to you to keep or remove this\n  serializeJson(doc, buffer-&gt;get(), len);\n  _ws-&gt;textAll(buffer);\n}\n</code></pre> <pre><code>void send(JsonDocument&amp; doc) {\n  const size_t len = measureJson(doc);\n\n  // this fork (originally from yubox-node-org), uses another API with shared pointer\n  auto buffer = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt;(len);\n  assert(buffer); // up to you to keep or remove this\n  serializeJson(doc, buffer-&gt;data(), len);\n  _ws-&gt;textAll(std::move(buffer));\n}\n</code></pre> <p>I recommend to use the official API <code>AsyncWebSocketMessageBuffer</code> to retain further compatibility.</p>"},{"location":"websockets/#async-websocket-plugin","title":"Async WebSocket Plugin","text":"<p>The server includes a web socket plugin which lets you define different WebSocket locations to connect to without starting another listening service or using different port</p> <p>See the WebSocket example here and WebSocketEasy example here.</p>"},{"location":"websockets/#async-websocket-event","title":"Async WebSocket Event","text":"<pre><code>void onEvent(AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len){\n  if(type == WS_EVT_CONNECT){\n    //client connected\n    os_printf(\"ws[%s][%u] connect\\n\", server-&gt;url(), client-&gt;id());\n    client-&gt;printf(\"Hello Client %u :)\", client-&gt;id());\n    client-&gt;ping();\n  } else if(type == WS_EVT_DISCONNECT){\n    //client disconnected\n    os_printf(\"ws[%s][%u] disconnect: %u\\n\", server-&gt;url(), client-&gt;id());\n  } else if(type == WS_EVT_ERROR){\n    //error was received from the other end\n    os_printf(\"ws[%s][%u] error(%u): %s\\n\", server-&gt;url(), client-&gt;id(), *((uint16_t*)arg), (char*)data);\n  } else if(type == WS_EVT_PONG){\n    //pong message was received (in response to a ping request maybe)\n    os_printf(\"ws[%s][%u] pong[%u]: %s\\n\", server-&gt;url(), client-&gt;id(), len, (len)?(char*)data:\"\");\n  } else if(type == WS_EVT_DATA){\n    //data packet\n    AwsFrameInfo * info = (AwsFrameInfo*)arg;\n    if(info-&gt;final &amp;&amp; info-&gt;index == 0 &amp;&amp; info-&gt;len == len){\n      //the whole message is in a single frame and we got all of it's data\n      os_printf(\"ws[%s][%u] %s-message[%llu]: \", server-&gt;url(), client-&gt;id(), (info-&gt;opcode == WS_TEXT)?\"text\":\"binary\", info-&gt;len);\n      if(info-&gt;opcode == WS_TEXT){\n        data[len] = 0;\n        os_printf(\"%s\\n\", (char*)data);\n      } else {\n        for(size_t i=0; i &lt; info-&gt;len; i++){\n          os_printf(\"%02x \", data[i]);\n        }\n        os_printf(\"\\n\");\n      }\n      if(info-&gt;opcode == WS_TEXT)\n        client-&gt;text(\"I got your text message\");\n      else\n        client-&gt;binary(\"I got your binary message\");\n    } else {\n      //message is comprised of multiple frames or the frame is split into multiple packets\n      if(info-&gt;index == 0){\n        if(info-&gt;num == 0)\n          os_printf(\"ws[%s][%u] %s-message start\\n\", server-&gt;url(), client-&gt;id(), (info-&gt;message_opcode == WS_TEXT)?\"text\":\"binary\");\n        os_printf(\"ws[%s][%u] frame[%u] start[%llu]\\n\", server-&gt;url(), client-&gt;id(), info-&gt;num, info-&gt;len);\n      }\n\n      os_printf(\"ws[%s][%u] frame[%u] %s[%llu - %llu]: \", server-&gt;url(), client-&gt;id(), info-&gt;num, (info-&gt;message_opcode == WS_TEXT)?\"text\":\"binary\", info-&gt;index, info-&gt;index + len);\n      if(info-&gt;message_opcode == WS_TEXT){\n        data[len] = 0;\n        os_printf(\"%s\\n\", (char*)data);\n      } else {\n        for(size_t i=0; i &lt; len; i++){\n          os_printf(\"%02x \", data[i]);\n        }\n        os_printf(\"\\n\");\n      }\n\n      if((info-&gt;index + len) == info-&gt;len){\n        os_printf(\"ws[%s][%u] frame[%u] end[%llu]\\n\", server-&gt;url(), client-&gt;id(), info-&gt;num, info-&gt;len);\n        if(info-&gt;final){\n          os_printf(\"ws[%s][%u] %s-message end\\n\", server-&gt;url(), client-&gt;id(), (info-&gt;message_opcode == WS_TEXT)?\"text\":\"binary\");\n          if(info-&gt;message_opcode == WS_TEXT)\n            client-&gt;text(\"I got your text message\");\n          else\n            client-&gt;binary(\"I got your binary message\");\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"websockets/#methods-for-sending-data-to-a-socket-client","title":"Methods for sending data to a socket client","text":"<pre><code>//Server methods\nAsyncWebSocket ws(\"/ws\");\n//printf to a client\nws.printf((uint32_t)client_id, arguments...);\n//printf to all clients\nws.printfAll(arguments...);\n//printf_P to a client\nws.printf_P((uint32_t)client_id, PSTR(format), arguments...);\n//printfAll_P to all clients\nws.printfAll_P(PSTR(format), arguments...);\n//send text to a client\nws.text((uint32_t)client_id, (char*)text);\nws.text((uint32_t)client_id, (uint8_t*)text, (size_t)len);\n//send text from PROGMEM to a client\nws.text((uint32_t)client_id, PSTR(\"text\"));\nconst char flash_text[] PROGMEM = \"Text to send\"\nws.text((uint32_t)client_id, FPSTR(flash_text));\n//send text to all clients\nws.textAll((char*)text);\nws.textAll((uint8_t*)text, (size_t)len);\n//send binary to a client\nws.binary((uint32_t)client_id, (char*)binary);\nws.binary((uint32_t)client_id, (uint8_t*)binary, (size_t)len);\n//send binary from PROGMEM to a client\nconst uint8_t flash_binary[] PROGMEM = { 0x01, 0x02, 0x03, 0x04 };\nws.binary((uint32_t)client_id, flash_binary, 4);\n//send binary to all clients\nws.binaryAll((char*)binary);\nws.binaryAll((uint8_t*)binary, (size_t)len);\n\n//client methods\nAsyncWebSocketClient * client;\n//printf\nclient-&gt;printf(arguments...);\n//printf_P\nclient-&gt;printf_P(PSTR(format), arguments...);\n//send text\nclient-&gt;text((char*)text);\nclient-&gt;text((uint8_t*)text, (size_t)len);\n//send text from PROGMEM\nclient-&gt;text(PSTR(\"text\"));\nconst char flash_text[] PROGMEM = \"Text to send\";\nclient-&gt;text(FPSTR(flash_text));\n//send binary\nclient-&gt;binary((char*)binary);\nclient-&gt;binary((uint8_t*)binary, (size_t)len);\n//send binary from PROGMEM\nconst uint8_t flash_binary[] PROGMEM = { 0x01, 0x02, 0x03, 0x04 };\nclient-&gt;binary(flash_binary, 4);\n</code></pre>"},{"location":"websockets/#direct-access-to-web-socket-message-buffer","title":"Direct access to web socket message buffer","text":"<p>When sending a web socket message using the above methods a buffer is created. Under certain circumstances you might want to manipulate or populate this buffer directly from your application, for example to prevent unnecessary duplications of the data. This example below shows how to create a buffer and print data to it from an ArduinoJson object then send it.</p> <pre><code>void sendDataWs(AsyncWebSocketClient * client)\n{\n    JsonDocument doc;\n    doc[\"a\"] = \"abc\";\n    doc[\"b\"] = \"abcd\";\n    doc[\"c\"] = \"abcde\";\n    doc[\"d\"] = \"abcdef\";\n    doc[\"e\"] = \"abcdefg\";\n    size_t len = measureJson(doc);\n    AsyncWebSocketMessageBuffer * buffer = ws.makeBuffer(len); //  creates a buffer (len + 1) for you.\n    if (buffer) {\n        serializeJson(doc, (char *)buffer-&gt;get(), len + 1);\n        if (client) {\n            client-&gt;text(buffer);\n        } else {\n            ws.textAll(buffer);\n        }\n    }\n}\n</code></pre>"},{"location":"websockets/#limiting-the-number-of-web-socket-clients","title":"Limiting the number of web socket clients","text":"<p>Browsers sometimes do not correctly close the websocket connection, even when the close() function is called in javascript. This will eventually exhaust the web server's resources and will cause the server to crash. Periodically calling the cleanClients() function from the main loop() function limits the number of clients by closing the oldest client when the maximum number of clients has been exceeded. This can called be every cycle, however, if you wish to use less power, then calling as infrequently as once per second is sufficient.</p> <pre><code>void loop(){\n  ws.cleanupClients();\n}\n</code></pre>"},{"location":"backup/","title":"Index","text":""},{"location":"backup/#espasyncwebserver","title":"ESPAsyncWebServer","text":""},{"location":"backup/#asynchronous-http-and-websocket-server-library-for-esp32-esp8266-rp2040-and-rp2350","title":"Asynchronous HTTP and WebSocket Server Library for ESP32, ESP8266, RP2040 and RP2350","text":"<p>Supports: WebSocket, SSE, Authentication, Arduino Json 7, File Upload, Static File serving, URL Rewrite, URL Redirect, etc.</p> <ul> <li>Documentation</li> <li>How to install</li> <li>Dependencies</li> <li>ESP32 / pioarduino</li> <li>ESP8266 / pioarduino</li> <li>Unofficial dependencies</li> </ul>"},{"location":"backup/#documentation","title":"Documentation","text":"<p>The complete project documentation is available in the Wiki section.</p>"},{"location":"backup/#how-to-install","title":"How to install","text":"<p>The library can be downloaded from the releases page at https://github.com/ESP32Async/ESPAsyncWebServer/releases.</p> <p>It is also deployed in these registries:</p> <ul> <li> <p>Arduino Library Registry: https://github.com/arduino/library-registry</p> </li> <li> <p>ESP Component Registry https://components.espressif.com/components/esp32async/espasyncwebserver</p> </li> <li> <p>PlatformIO Registry: https://registry.platformio.org/libraries/esp32async/ESPAsyncWebServer</p> </li> <li> <p>Use: <code>lib_deps=ESP32Async/ESPAsyncWebServer</code> to point to latest version</p> </li> <li>Use: <code>lib_deps=ESP32Async/ESPAsyncWebServer @ ^&lt;x.y.z&gt;</code> to point to latest version with the same major version</li> <li>Use: <code>lib_deps=ESP32Async/ESPAsyncWebServer @ &lt;x.y.z&gt;</code> to always point to the same version (reproductible build)</li> </ul>"},{"location":"backup/#dependencies","title":"Dependencies","text":""},{"location":"backup/#esp32-pioarduino","title":"ESP32 / pioarduino","text":"<pre><code>[env:stable]\nplatform = https://github.com/pioarduino/platform-espressif32/releases/download/stable/platform-espressif32.zip\nlib_compat_mode = strict\nlib_ldf_mode = chain\nlib_deps =\n  ESP32Async/AsyncTCP\n  ESP32Async/ESPAsyncWebServer\n</code></pre>"},{"location":"backup/#esp8266-pioarduino","title":"ESP8266 / pioarduino","text":"<pre><code>[env:stable]\nplatform = espressif8266\nlib_compat_mode = strict\nlib_ldf_mode = chain\nlib_deps =\n  ESP32Async/ESPAsyncTCP\n  ESP32Async/ESPAsyncWebServer\n</code></pre>"},{"location":"backup/#libretiny-bk7231nt-rtl8710b-etc","title":"LibreTiny (BK7231N/T, RTL8710B, etc.)","text":"<p>Version 1.9.1 or newer is required.</p> <pre><code>[env:stable]\nplatform = libretiny @ ^1.9.1\nlib_ldf_mode = chain\nlib_deps =\n  ESP32Async/AsyncTCP\n  ESP32Async/ESPAsyncWebServer\n</code></pre>"},{"location":"backup/#unofficial-dependencies","title":"Unofficial dependencies","text":"<p>AsyncTCPSock</p> <p>AsyncTCPSock can be used instead of AsyncTCP by excluding AsyncTCP from the library dependencies and adding AsyncTCPSock instead:</p> <pre><code>lib_compat_mode = strict\nlib_ldf_mode = chain\nlib_deps =\n  https://github.com/ESP32Async/AsyncTCPSock/archive/refs/tags/v1.0.3-dev.zip\n  ESP32Async/ESPAsyncWebServer\nlib_ignore =\n  AsyncTCP\n  ESP32Async/AsyncTCP\n</code></pre> <p>RPAsyncTCP</p> <p>RPAsyncTCP replaces AsyncTCP to provide support for RP2040(+WiFi) and RP2350(+WiFi) boards. For example - Raspberry Pi Pico W and Raspberry Pi Pico 2W.</p> <pre><code>lib_compat_mode = strict\nlib_ldf_mode = chain\nplatform = https://github.com/maxgerhardt/platform-raspberrypi.git\nboard = rpipicow\nboard_build.core = earlephilhower\nlib_deps =\n  ayushsharma82/RPAsyncTCP@^1.3.2\n  ESP32Async/ESPAsyncWebServer\nlib_ignore =\n  lwIP_ESPHost\nbuild_flags = ${env.build_flags}\n  -Wno-missing-field-initializers\n</code></pre>"},{"location":"backup/#important-recommendations-for-build-options","title":"Important recommendations for build options","text":"<p>Most of the crashes are caused by improper use or configuration of the AsyncTCP library used for the project. Here are some recommendations to avoid them and build-time flags you can change.</p> <p><code>CONFIG_ASYNC_TCP_MAX_ACK_TIME</code> - defines a timeout for TCP connection to be considered alive when waiting for data. In some bad network conditions you might consider increasing it.</p> <p><code>CONFIG_ASYNC_TCP_QUEUE_SIZE</code> - defines the length of the queue for events related to connections handling. Both the server and AsyncTCP library were optimized to control the queue automatically. Do NOT try blindly increasing the queue size, it does not help you in a way you might think it is. If you receive debug messages about queue throttling, try to optimize your server callbacks code to execute as fast as possible. Read #165 thread, it might give you some hints.</p> <p><code>CONFIG_ASYNC_TCP_RUNNING_CORE</code> - CPU core thread affinity that runs the queue events handling and executes server callbacks. Default is ANY core, so it means that for dualcore SoCs both cores could handle server activities. If your server's code is too heavy and unoptimized or you see that sometimes server might affect other network activities, you might consider to bind it to the same core that runs Arduino code (1) to minimize affect on radio part. Otherwise you can leave the default to let RTOS decide where to run the thread based on priority</p> <p><code>CONFIG_ASYNC_TCP_STACK_SIZE</code> - stack size for the thread that runs sever events and callbacks. Default is 16k that is a way too much waste for well-defined short async code or simple static file handling. You might want to cosider reducing it to 4-8k to same RAM usage. If you do not know what this is or not sure about your callback code demands - leave it as default, should be enough even for very hungry callbacks in most cases.</p> <p>[!NOTE] This relates to ESP32 only, ESP8266 uses different ESPAsyncTCP lib that does not has this build options</p> <p>I personally use the following configuration in my projects:</p> <pre><code>  -D CONFIG_ASYNC_TCP_MAX_ACK_TIME=5000   // (keep default)\n  -D CONFIG_ASYNC_TCP_PRIORITY=10         // (keep default)\n  -D CONFIG_ASYNC_TCP_QUEUE_SIZE=64       // (keep default)\n  -D CONFIG_ASYNC_TCP_RUNNING_CORE=1      // force async_tcp task to be on same core as Arduino app (default is any core)\n  -D CONFIG_ASYNC_TCP_STACK_SIZE=4096     // reduce the stack size (default is 16K)\n</code></pre> <p>If you need to serve chunk requests with a really low buffer (which should be avoided), you can set <code>-D ASYNCWEBSERVER_USE_CHUNK_INFLIGHT=0</code> to disable the in-flight control.</p>"},{"location":"backup/wiki/","title":"ESPAsyncWebServer","text":""},{"location":"backup/wiki/#asynchronous-http-and-websocket-server-library-for-esp32-esp8266-and-rp2040","title":"Asynchronous HTTP and WebSocket Server Library for ESP32, ESP8266 and RP2040","text":"<p>Supports: WebSocket, SSE, Authentication, Arduino Json 7, File Upload, Static File serving, URL Rewrite, URL Redirect, etc.</p> <ul> <li>Compatibility</li> <li>How to install</li> <li>Dependencies</li> <li>ESP32 / pioarduino</li> <li>ESP8266 / pioarduino</li> <li>Unofficial dependencies</li> <li>Important recommendations for build options</li> <li>Changes in this repository</li> <li>Performance</li> <li><code>AsyncWebSocketMessageBuffer</code> and <code>makeBuffer()</code></li> <li>How to replace a response</li> <li>How to use Middleware</li> <li>How to use authentication with AsyncAuthenticationMiddleware</li> <li>Migration to Middleware to improve performance and memory usage</li> <li>Request Continuation</li> <li>Original Documentation</li> </ul>"},{"location":"backup/wiki/#compatibility","title":"Compatibility","text":"<ul> <li>ESP32, ESP8266, RP2040</li> <li>Arduino Core 2.x and 3.x</li> </ul>"},{"location":"backup/wiki/#how-to-install","title":"How to install","text":"<p>The library can be downloaded from the releases page at https://github.com/ESP32Async/ESPAsyncWebServer/releases.</p> <p>It is also deployed in these registries:</p> <ul> <li> <p>Arduino Library Registry: https://github.com/arduino/library-registry</p> </li> <li> <p>ESP Component Registry https://components.espressif.com/components/esp32async/espasyncwebserver</p> </li> <li> <p>PlatformIO Registry: https://registry.platformio.org/libraries/esp32async/ESPAsyncWebServer</p> </li> <li> <p>Use: <code>lib_deps=ESP32Async/ESPAsyncWebServer</code> to point to latest version</p> </li> <li>Use: <code>lib_deps=ESP32Async/ESPAsyncWebServer @ ^&lt;x.y.z&gt;</code> to point to latest version with the same major version</li> <li>Use: <code>lib_deps=ESP32Async/ESPAsyncWebServer @ &lt;x.y.z&gt;</code> to always point to the same version (reproductible build)</li> </ul>"},{"location":"backup/wiki/#dependencies","title":"Dependencies","text":""},{"location":"backup/wiki/#esp32-pioarduino","title":"ESP32 / pioarduino","text":"<pre><code>[env:stable]\nplatform = https://github.com/pioarduino/platform-espressif32/releases/download/stable/platform-espressif32.zip\nlib_compat_mode = strict\nlib_ldf_mode = chain\nlib_deps =\n  ESP32Async/AsyncTCP\n  ESP32Async/ESPAsyncWebServer\n</code></pre>"},{"location":"backup/wiki/#esp8266-pioarduino","title":"ESP8266 / pioarduino","text":"<pre><code>[env:stable]\nplatform = espressif8266\nlib_compat_mode = strict\nlib_ldf_mode = chain\nlib_deps =\n  ESP32Async/ESPAsyncTCP\n  ESP32Async/ESPAsyncWebServer\n</code></pre>"},{"location":"backup/wiki/#unofficial-dependencies","title":"Unofficial dependencies","text":"<p>AsyncTCPSock</p> <p>AsyncTCPSock can be used instead of AsyncTCP by excluding AsyncTCP from the library dependencies and adding AsyncTCPSock instead:</p> <pre><code>lib_compat_mode = strict\nlib_ldf_mode = chain\nlib_deps =\n  https://github.com/ESP32Async/AsyncTCPSock/archive/refs/tags/v1.0.3-dev.zip\n  ESP32Async/ESPAsyncWebServer\nlib_ignore =\n  AsyncTCP\n  ESP32Async/AsyncTCP\n</code></pre> <p>AsyncTCP_RP2040W</p> <p>AsyncTCP_RP2040W provides support for RP2040 and replaced AsyncTCP in this case:</p> <pre><code>lib_compat_mode = strict\nlib_ldf_mode = chain\nplatform = https://github.com/maxgerhardt/platform-raspberrypi.git\nboard = rpipicow\nboard_build.core = earlephilhower\nlib_deps =\n  khoih-prog/AsyncTCP_RP2040W @ 1.2.0\n  ESP32Async/ESPAsyncWebServer\nlib_ignore =\n  lwIP_ESPHost\nbuild_flags = ${env.build_flags}\n  -Wno-missing-field-initializers\n</code></pre>"},{"location":"backup/wiki/#important-recommendations-for-build-options","title":"Important recommendations for build options","text":"<p>Most of the crashes are caused by improper use or configuration of the AsyncTCP library used for the project. Here are some recommendations to avoid them and build-time flags you can change.</p> <p><code>CONFIG_ASYNC_TCP_MAX_ACK_TIME</code> - defines a timeout for TCP connection to be considered alive when waiting for data. In some bad network conditions you might consider increasing it.</p> <p><code>CONFIG_ASYNC_TCP_QUEUE_SIZE</code> - defines the length of the queue for events related to connections handling. Both the server and AsyncTCP library were optimized to control the queue automatically. Do NOT try blindly increasing the queue size, it does not help you in a way you might think it is. If you receive debug messages about queue throttling, try to optimize your server callbacks code to execute as fast as possible. Read #165 thread, it might give you some hints.</p> <p><code>CONFIG_ASYNC_TCP_RUNNING_CORE</code> - CPU core thread affinity that runs the queue events handling and executes server callbacks. Default is ANY core, so it means that for dualcore SoCs both cores could handle server activities. If your server's code is too heavy and unoptimized or you see that sometimes server might affect other network activities, you might consider to bind it to the same core that runs Arduino code (1) to minimize affect on radio part. Otherwise you can leave the default to let RTOS decide where to run the thread based on priority</p> <p><code>CONFIG_ASYNC_TCP_STACK_SIZE</code> - stack size for the thread that runs sever events and callbacks. Default is 16k that is a way too much waste for well-defined short async code or simple static file handling. You might want to cosider reducing it to 4-8k to same RAM usage. If you do not know what this is or not sure about your callback code demands - leave it as default, should be enough even for very hungry callbacks in most cases.</p> <p>[!NOTE] This relates to ESP32 only, ESP8266 uses different ESPAsyncTCP lib that does not has this build options</p> <p>I personally use the following configuration in my projects:</p> <pre><code>  -D CONFIG_ASYNC_TCP_MAX_ACK_TIME=5000   // (keep default)\n  -D CONFIG_ASYNC_TCP_PRIORITY=10         // (keep default)\n  -D CONFIG_ASYNC_TCP_QUEUE_SIZE=64       // (keep default)\n  -D CONFIG_ASYNC_TCP_RUNNING_CORE=1      // force async_tcp task to be on same core as Arduino app (default is any core)\n  -D CONFIG_ASYNC_TCP_STACK_SIZE=4096     // reduce the stack size (default is 16K)\n</code></pre> <p>If you need to serve chunk requests with a really low buffer (which should be avoided), you can set <code>-D ASYNCWEBSERVER_USE_CHUNK_INFLIGHT=0</code> to disable the in-flight control.</p>"},{"location":"backup/wiki/#changes-in-this-repository","title":"Changes in this repository","text":"<ul> <li>(bug) A lot of bug fixes</li> <li>(ci) Better CI with a complete matrix of Arduino versions and boards</li> <li>(ci) Deployed in PlatformIO registry and Arduino IDE library manager</li> <li>(feat) Arduino 3 / ESP-IDF 5 compatibility</li> <li>(feat) ArduinoJson 7 compatibility</li> <li>(feat) ESP32 / ESP8266 / RP2040 support</li> <li>(feat) MessagePack support</li> <li>(feat) Middleware support with pre-built middlewares for authentication, authorization, rate limiting, logging, cors, etc.</li> <li>(feat) Request attributes to store data on the request object</li> <li>(feat) Response header control and override</li> <li>(feat) Response override: support the ability to replace a previously sent response by another one</li> <li>(feat) Resumable download support using HEAD and bytes range</li> <li>(feat) <code>StreamConcat</code> example to show how to stream multiple files in one response</li> <li>(feat) Removed ESPIDF Editor (this is not the role of a web server library to do that - get the source files from the original repos if required)</li> <li>(perf) AsyncTCPSock support: AsyncTCP can be ignored and AsyncTCPSock used instead</li> <li>(perf) <code>char*</code> overloads to avoid using <code>String</code></li> <li>(perf) <code>DEFAULT_MAX_WS_CLIENTS</code> to change the number of allows WebSocket clients and use <code>cleanupClients()</code> to help cleanup resources about dead clients</li> <li>(perf) <code>setCloseClientOnQueueFull(bool)</code> which can be set on a client to either close the connection or discard messages but not close the connection when the queue is full</li> <li>(perf) <code>SSE_MAX_QUEUED_MESSAGES</code> to control the maximum number of messages that can be queued for a SSE client</li> <li>(perf) <code>WS_MAX_QUEUED_MESSAGES</code>: control the maximum number of messages that can be queued for a Websocket client</li> <li>(perf) in-flight buffer control and queue congestion avoidance to help to improve parallel connections handling, high volume data transfers and mitigate poor implemented slow user-code callbacks delayes on connections handling</li> <li>(perf) Code size improvements</li> <li>(perf) Lot of code cleanup and optimizations</li> <li>(perf) Performance improvements in terms of memory, speed and size</li> </ul> <p>WARNING: Important notes about future version 4.x</p> <p>ESPAsyncWebServer is now at version 3.x, where we try to keep the API compatibility with original project as much as possible.</p> <p>We plan on creating a next major 4.x version that will:</p> <ol> <li>Drop support for ESP8266, which goes EOL in a few years</li> <li>Drop support for Arduino 2.x and ESP-IDF 4.x. The library will be compatible with latest Arduino and ESP-IDF</li> <li>Drop support for ArduinoJson 5.x and 6.x. The library will be compatible with latest ArduinoJson</li> </ol> <p>So if you need one of these feature, you will have to stick with the current 3.x. All releases we do will not cease to exist: all 3.x releases will stay in the release page. That is why we have tags and a release cycle.</p> <p>Maintaining a library for ESP8266 and RP2040 has a real cost and clearly what we see is that most users helping are on ESP32.</p> <p>If you are an ESP8266 user and want to help improve current 3.x, you are more than welcomed to contribute to this community effort.</p>"},{"location":"backup/wiki/#performance","title":"Performance","text":"<p>Performance of <code>ESP32Async/ESPAsyncWebServer</code>:</p> <pre><code>&gt; brew install autocannon\n&gt; autocannon -c 10 -w 10 -d 20 http://192.168.4.1\n</code></pre> <p>With <code>ESP32Async/AsyncTCP</code></p> <p></p> <p>With <code>https://github.com/ESP32Async/AsyncTCPSock/archive/refs/tags/v1.0.3-dev.zip</code>:</p> <p></p> <p>SSE performance</p> <p>In the example, there is an endpoint <code>/events</code> with some comments showing how these metrics are calculated.</p> <p>Test is running for 20 seconds with 10 connections.</p> <pre><code>// With AsyncTCP, with 10 workers: no message discarded from the queue\n//\n// Total: 2038 events, 509.50 events / second\n// Total: 2120 events, 530.00 events / second\n// Total: 2119 events, 529.75 events / second\n// Total: 2038 events, 509.50 events / second\n// Total: 2037 events, 509.25 events / second\n// Total: 2119 events, 529.75 events / second\n// Total: 2119 events, 529.75 events / second\n// Total: 2120 events, 530.00 events / second\n// Total: 2038 events, 509.50 events / second\n// Total: 2038 events, 509.50 events / second\n//\n// With AsyncTCPSock, with 10 workers: no message discarded from the queue\n//\n// Total: 2038 events, 509.50 events / second\n// Total: 2120 events, 530.00 events / second\n// Total: 2119 events, 529.75 events / second\n// Total: 2038 events, 509.50 events / second\n// Total: 2037 events, 509.25 events / second\n// Total: 2119 events, 529.75 events / second\n// Total: 2119 events, 529.75 events / second\n// Total: 2120 events, 530.00 events / second\n// Total: 2038 events, 509.50 events / second\n// Total: 2038 events, 509.50 events / second\n</code></pre>"},{"location":"backup/wiki/#asyncwebsocketmessagebuffer-and-makebuffer","title":"<code>AsyncWebSocketMessageBuffer</code> and <code>makeBuffer()</code>","text":"<p>The fork from yubox-node-org introduces some breaking API changes compared to the original library, especially regarding the use of <code>std::shared_ptr&lt;std::vector&lt;uint8_t&gt;&gt;</code> for WebSocket.</p> <p>This library is compatible with the original library from me-no-dev regarding WebSocket, and wraps the optimizations done by <code>yubox-node-org</code> in the <code>AsyncWebSocketMessageBuffer</code> class. So you have the choice of which API to use.</p> <p>Here are examples for serializing a Json document in a websocket message buffer:</p> <pre><code>void send(JsonDocument&amp; doc) {\n  const size_t len = measureJson(doc);\n\n  // original API from me-no-dev\n  AsyncWebSocketMessageBuffer* buffer = _ws-&gt;makeBuffer(len);\n  assert(buffer); // up to you to keep or remove this\n  serializeJson(doc, buffer-&gt;get(), len);\n  _ws-&gt;textAll(buffer);\n}\n</code></pre> <pre><code>void send(JsonDocument&amp; doc) {\n  const size_t len = measureJson(doc);\n\n  // this fork (originally from yubox-node-org), uses another API with shared pointer\n  auto buffer = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt;(len);\n  assert(buffer); // up to you to keep or remove this\n  serializeJson(doc, buffer-&gt;data(), len);\n  _ws-&gt;textAll(std::move(buffer));\n}\n</code></pre> <p>I recommend to use the official API <code>AsyncWebSocketMessageBuffer</code> to retain further compatibility.</p>"},{"location":"backup/wiki/#how-to-replace-a-response","title":"How to replace a response","text":"<pre><code>  // It is possible to replace a response.\n  // The previous one will be deleted.\n  // Response sending happens when the handler returns.\n  server.on(\"/replace\", HTTP_GET, [](AsyncWebServerRequest* request) {\n    request-&gt;send(200, \"text/plain\", \"Hello, world\");\n    // oups! finally we want to send a different response\n    request-&gt;send(400, \"text/plain\", \"validation error\");\n  });\n</code></pre> <p>This will send error 400 instead of 200.</p>"},{"location":"backup/wiki/#how-to-use-middleware","title":"How to use Middleware","text":"<p>Middleware is a way to intercept requests to perform some operations on them, like authentication, authorization, logging, etc and also act on the response headers.</p> <p>Middleware can either be attached to individual handlers, attached at the server level (thus applied to all handlers), or both. They will be executed in the order they are attached, and they can stop the request processing by sending a response themselves.</p> <p>You can have a look at the examples for some use cases.</p> <p>For example, such middleware would handle authentication and set some attributes on the request to make them available for the next middleware and for the handler which will process the request.</p> <pre><code>AsyncMiddlewareFunction complexAuth([](AsyncWebServerRequest* request, ArMiddlewareNext next) {\n  if (!request-&gt;authenticate(\"user\", \"password\")) {\n    return request-&gt;requestAuthentication();\n  }\n\n  request-&gt;setAttribute(\"user\", \"Mathieu\");\n  request-&gt;setAttribute(\"role\", \"staff\");\n\n  next(); // continue processing\n\n  // you can act one the response object\n  request-&gt;getResponse()-&gt;addHeader(\"X-Rate-Limit\", \"200\");\n});\n</code></pre> <p>Here are the list of available middlewares:</p> <ul> <li><code>AsyncMiddlewareFunction</code>: can convert a lambda function (<code>ArMiddlewareCallback</code>) to a middleware</li> <li><code>AsyncAuthenticationMiddleware</code>: to handle basic/digest authentication globally or per handler</li> <li><code>AsyncAuthorizationMiddleware</code>: to handle authorization globally or per handler</li> <li><code>AsyncCorsMiddleware</code>: to handle CORS preflight request globally or per handler</li> <li><code>AsyncHeaderFilterMiddleware</code>: to filter out headers from the request</li> <li><code>AsyncHeaderFreeMiddleware</code>: to only keep some headers from the request, and remove the others</li> <li><code>LoggerMiddleware</code>: to log requests globally or per handler with the same pattern as curl. Will also record request processing time</li> <li><code>AsyncRateLimitMiddleware</code>: to limit the number of requests on a windows of time globally or per handler</li> </ul>"},{"location":"backup/wiki/#how-to-use-authentication-with-asyncauthenticationmiddleware","title":"How to use authentication with AsyncAuthenticationMiddleware","text":"<p>Do not use the <code>setUsername()</code> and <code>setPassword()</code> methods on the handlers anymore. They are deprecated. These methods were causing a copy of the username and password for each handler, which is not efficient.</p> <p>Now, you can use the <code>AsyncAuthenticationMiddleware</code> to handle authentication globally or per handler.</p> <pre><code>AsyncAuthenticationMiddleware authMiddleware;\n\n// [...]\n\nauthMiddleware.setAuthType(AsyncAuthType::AUTH_DIGEST);\nauthMiddleware.setRealm(\"My app name\");\nauthMiddleware.setUsername(\"admin\");\nauthMiddleware.setPassword(\"admin\");\nauthMiddleware.setAuthFailureMessage(\"Authentication failed\");\nauthMiddleware.generateHash(); // optimization to avoid generating the hash at each request\n\n// [...]\n\nserver.addMiddleware(&amp;authMiddleware); // globally add authentication to the server\n\n// [...]\n\nmyHandler.addMiddleware(&amp;authMiddleware); // add authentication to a specific handler\n</code></pre>"},{"location":"backup/wiki/#migration-to-middleware-to-improve-performance-and-memory-usage","title":"Migration to Middleware to improve performance and memory usage","text":"<ul> <li><code>AsyncEventSource.authorizeConnect(...)</code> =&gt; do not use this method anymore: add a common <code>AsyncAuthorizationMiddleware</code> to the handler or server, and make sure to add it AFTER the <code>AsyncAuthenticationMiddleware</code> if you use authentication.</li> <li><code>AsyncWebHandler.setAuthentication(...)</code> =&gt; do not use this method anymore: add a common <code>AsyncAuthenticationMiddleware</code> to the handler or server</li> <li><code>ArUploadHandlerFunction</code> and <code>ArBodyHandlerFunction</code> =&gt; these callbacks receiving body data and upload and not calling anymore the authentication code for performance reasons.   These callbacks can be called multiple times during request parsing, so this is up to the user to now call the <code>AsyncAuthenticationMiddleware.allowed(request)</code> if needed and ideally when the method is called for the first time.   These callbacks are also not triggering the whole middleware chain since they are not part of the request processing workflow (they are not the final handler).</li> </ul>"},{"location":"backup/wiki/#request-continuation","title":"Request Continuation","text":"<p>Request Continuation is the ability to pause the processing of a request (the actual sending over the network) to be able to let another task commit the response on the network later.</p> <p>This is a common supported use case amongst web servers.</p> <p>A usage example can be found in the example called RequestContinuation.ino</p> <p>In the handler receiving the request, just execute:</p> <pre><code>AsyncWebServerRequestPtr ptr = request-&gt;pause();\n</code></pre> <p>This will pause the request and return a <code>AsyncWebServerRequestPtr</code> (this is a weak pointer).</p> <p>The AsyncWebServerRequestPtr is the ONLY object authorized to leave the scope of the request handler.</p> <p>Save somewhere this smart pointer and use it later to commit the response like this:</p> <pre><code>// you can check for expiration\nif (requestPtr.expired()) {\n  // the request connection was closed some time ago so the request is not accessible anymore\n\n} else if (longRunningTaskFinished) {\n  // this is what you always need to do when you want to access the request.\n  if (auto request = requestPtr.lock()) {\n    // send back the response\n    request-&gt;send(200, contentType, ...);\n\n  } else {\n    // the connection has been closed so the request is not accessible anymore\n  }\n}\n</code></pre> <p>Most of the time you can simply do like below if checking expiration is not needed:</p> <pre><code>if (auto request = requestPtr.lock()) {\n  // send back the response\n  request-&gt;send(200, contentType, ...);\n}\n</code></pre>"},{"location":"backup/wiki/#original-documentation","title":"Original Documentation","text":"<ul> <li>Why should you care</li> <li>Important things to remember</li> <li>Principles of operation</li> <li>The Async Web server</li> <li>Request Life Cycle</li> <li>Rewrites and how do they work</li> <li>Handlers and how do they work</li> <li>Responses and how do they work</li> <li>Template processing</li> <li>Libraries and projects that use AsyncWebServer</li> <li>Request Variables</li> <li>Common Variables</li> <li>Headers</li> <li>GET, POST and FILE parameters</li> <li>FILE Upload handling</li> <li>Body data handling</li> <li>JSON body handling with ArduinoJson</li> <li>Responses</li> <li>Redirect to another URL</li> <li>Basic response with HTTP Code</li> <li>Basic response with HTTP Code and extra headers</li> <li>Basic response with string content</li> <li>Basic response with string content and extra headers</li> <li>Send large webpage from PROGMEM</li> <li>Send large webpage from PROGMEM and extra headers</li> <li>Send large webpage from PROGMEM containing templates</li> <li>Send large webpage from PROGMEM containing templates and extra headers</li> <li>Send binary content from PROGMEM</li> <li>Respond with content coming from a Stream</li> <li>Respond with content coming from a Stream and extra headers</li> <li>Respond with content coming from a Stream containing templates</li> <li>Respond with content coming from a Stream containing templates and extra headers</li> <li>Respond with content coming from a File</li> <li>Respond with content coming from a File and extra headers</li> <li>Respond with content coming from a File containing templates</li> <li>Respond with content using a callback</li> <li>Respond with content using a callback and extra headers</li> <li>Respond with file content using a callback and extra headers</li> <li>Respond with content using a callback containing templates</li> <li>Respond with content using a callback containing templates and extra headers</li> <li>Chunked Response</li> <li>Chunked Response containing templates</li> <li>Print to response</li> <li>ArduinoJson Basic Response</li> <li>ArduinoJson Advanced Response</li> <li>Serving static files</li> <li>Serving specific file by name</li> <li>Serving files in directory</li> <li>Serving static files with authentication</li> <li>Specifying Cache-Control header</li> <li>Specifying Date-Modified header</li> <li>Specifying Template Processor callback</li> <li>Serving static files by custom handling</li> <li>Param Rewrite With Matching</li> <li>Using filters</li> <li>Serve different site files in AP mode</li> <li>Rewrite to different index on AP</li> <li>Serving different hosts</li> <li>Determine interface inside callbacks</li> <li>Bad Responses</li> <li>Respond with content using a callback without content length to HTTP/1.0 clients</li> <li>Async WebSocket Plugin</li> <li>Async WebSocket Event</li> <li>Methods for sending data to a socket client</li> <li>Direct access to web socket message buffer</li> <li>Limiting the number of web socket clients</li> <li>Async Event Source Plugin</li> <li>Setup Event Source on the server</li> <li>Setup Event Source in the browser</li> <li>Scanning for available WiFi Networks</li> <li>Remove handlers and rewrites</li> <li>Setting up the server</li> <li>Setup global and class functions as request handlers</li> <li>Methods for controlling websocket connections</li> <li>Adding Default Headers</li> <li>Path variable</li> </ul>"},{"location":"backup/wiki/#why-should-you-care","title":"Why should you care","text":"<ul> <li>Using asynchronous network means that you can handle more than one connection at the same time</li> <li>You are called once the request is ready and parsed</li> <li>When you send the response, you are immediately ready to handle other connections   while the server is taking care of sending the response in the background</li> <li>Speed is OMG</li> <li>Easy to use API, HTTP Basic and Digest MD5 Authentication (default), ChunkedResponse</li> <li>Easily extendible to handle any type of content</li> <li>Supports Continue 100</li> <li>Async WebSocket plugin offering different locations without extra servers or ports</li> <li>Async EventSource (Server-Sent Events) plugin to send events to the browser</li> <li>URL Rewrite plugin for conditional and permanent url rewrites</li> <li>ServeStatic plugin that supports cache, Last-Modified, default index and more</li> <li>Simple template processing engine to handle templates</li> </ul>"},{"location":"backup/wiki/#important-things-to-remember","title":"Important things to remember","text":"<ul> <li>This is fully asynchronous server and as such does not run on the loop thread.</li> <li>You can not use yield or delay or any function that uses them inside the callbacks</li> <li>The server is smart enough to know when to close the connection and free resources</li> <li>You can not send more than one response to a single request</li> </ul>"},{"location":"backup/wiki/#principles-of-operation","title":"Principles of operation","text":""},{"location":"backup/wiki/#the-async-web-server","title":"The Async Web server","text":"<ul> <li>Listens for connections</li> <li>Wraps the new clients into <code>Request</code></li> <li>Keeps track of clients and cleans memory</li> <li>Manages <code>Rewrites</code> and apply them on the request url</li> <li>Manages <code>Handlers</code> and attaches them to Requests</li> </ul>"},{"location":"backup/wiki/#request-life-cycle","title":"Request Life Cycle","text":"<ul> <li>TCP connection is received by the server</li> <li>The connection is wrapped inside <code>Request</code> object</li> <li>When the request head is received (type, url, get params, http version and host),   the server goes through all <code>Rewrites</code> (in the order they were added) to rewrite the url and inject query parameters,   next, it goes through all attached <code>Handlers</code>(in the order they were added) trying to find one   that <code>canHandle</code> the given request. If none are found, the default(catch-all) handler is attached.</li> <li>The rest of the request is received, calling the <code>handleUpload</code> or <code>handleBody</code> methods of the <code>Handler</code> if they are needed (POST+File/Body)</li> <li>When the whole request is parsed, the result is given to the <code>handleRequest</code> method of the <code>Handler</code> and is ready to be responded to</li> <li>In the <code>handleRequest</code> method, to the <code>Request</code> is attached a <code>Response</code> object (see below) that will serve the response data back to the client</li> <li>When the <code>Response</code> is sent, the client is closed and freed from the memory</li> </ul>"},{"location":"backup/wiki/#rewrites-and-how-do-they-work","title":"Rewrites and how do they work","text":"<ul> <li>The <code>Rewrites</code> are used to rewrite the request url and/or inject get parameters for a specific request url path.</li> <li>All <code>Rewrites</code> are evaluated on the request in the order they have been added to the server.</li> <li>The <code>Rewrite</code> will change the request url only if the request url (excluding get parameters) is fully match   the rewrite url, and when the optional <code>Filter</code> callback return true.</li> <li>Setting a <code>Filter</code> to the <code>Rewrite</code> enables to control when to apply the rewrite, decision can be based on   request url, http version, request host/port/target host, get parameters or the request client's localIP or remoteIP.</li> <li>Two filter callbacks are provided: <code>ON_AP_FILTER</code> to execute the rewrite when request is made to the AP interface,   <code>ON_STA_FILTER</code> to execute the rewrite when request is made to the STA interface.</li> <li>The <code>Rewrite</code> can specify a target url with optional get parameters, e.g. <code>/to-url?with=params</code></li> </ul>"},{"location":"backup/wiki/#handlers-and-how-do-they-work","title":"Handlers and how do they work","text":"<ul> <li>The <code>Handlers</code> are used for executing specific actions to particular requests</li> <li>One <code>Handler</code> instance can be attached to any request and lives together with the server</li> <li>Setting a <code>Filter</code> to the <code>Handler</code> enables to control when to apply the handler, decision can be based on   request url, http version, request host/port/target host, get parameters or the request client's localIP or remoteIP.</li> <li>Two filter callbacks are provided: <code>ON_AP_FILTER</code> to execute the rewrite when request is made to the AP interface,   <code>ON_STA_FILTER</code> to execute the rewrite when request is made to the STA interface.</li> <li>The <code>canHandle</code> method is used for handler specific control on whether the requests can be handled   and for declaring any interesting headers that the <code>Request</code> should parse. Decision can be based on request   method, request url, http version, request host/port/target host and get parameters</li> <li>Once a <code>Handler</code> is attached to given <code>Request</code> (<code>canHandle</code> returned true)   that <code>Handler</code> takes care to receive any file/data upload and attach a <code>Response</code>   once the <code>Request</code> has been fully parsed</li> <li><code>Handlers</code> are evaluated in the order they are attached to the server. The <code>canHandle</code> is called only   if the <code>Filter</code> that was set to the <code>Handler</code> return true.</li> <li>The first <code>Handler</code> that can handle the request is selected, not further <code>Filter</code> and <code>canHandle</code> are called.</li> </ul>"},{"location":"backup/wiki/#responses-and-how-do-they-work","title":"Responses and how do they work","text":"<ul> <li>The <code>Response</code> objects are used to send the response data back to the client</li> <li>The <code>Response</code> object lives with the <code>Request</code> and is freed on end or disconnect</li> <li>Different techniques are used depending on the response type to send the data in packets   returning back almost immediately and sending the next packet when this one is received.   Any time in between is spent to run the user loop and handle other network packets</li> <li>Responding asynchronously is probably the most difficult thing for most to understand</li> <li>Many different options exist for the user to make responding a background task</li> </ul>"},{"location":"backup/wiki/#template-processing","title":"Template processing","text":"<ul> <li>ESPAsyncWebserver contains simple template processing engine.</li> <li>Template processing can be added to most response types.</li> <li>Currently it supports only replacing template placeholders with actual values. No conditional processing, cycles, etc.</li> <li>Placeholders are delimited with <code>%</code> symbols. Like this: <code>%TEMPLATE_PLACEHOLDER%</code>.</li> <li>It works by extracting placeholder name from response text and passing it to user provided function which should return actual value to be used instead of placeholder.</li> <li>Since it's user provided function, it is possible for library users to implement conditional processing and cycles themselves.</li> <li>Since it's impossible to know the actual response size after template processing step in advance (and, therefore, to include it in response headers), the response becomes chunked.</li> </ul>"},{"location":"backup/wiki/#libraries-and-projects-that-use-asyncwebserver","title":"Libraries and projects that use AsyncWebServer","text":"<ul> <li>Beelance - Autonomous and remotely connected weight scale for beehives \ud83d\udc1d</li> <li>ElegantOTA - OTA updates made slick and simple for everyone!</li> <li>ESP Radio - Icecast radio based on ESP8266 and VS1053</li> <li>ESP-DASH - ESP-DASH is a library for ESP32 Arduino that facilitates the use of a dashboard in an asynchronous way. I have contributed most of the recently newly added fixes and features of the OSS and Pro version</li> <li>ESP-RFID - MFRC522 RFID Access Control Management project for ESP8266.</li> <li>ESPurna - ESPurna (\"spark\" in Catalan) is a custom C firmware for ESP8266 based smart switches. It was originally developed with the ITead Sonoff in mind.</li> <li>FauxmoESP - Belkin WeMo emulator library for ESP8266.</li> <li>MycilaESPConnect - Simple &amp; Easy Network Manager with Captive Portal for ESP32 supporting Ethernet</li> <li>MycilaJSY - Arduino / ESP32 library for the JSY1031, JSY-MK-163, JSY-MK-193, JSY-MK-194, JSY-MK-227, JSY-MK-229, JSY-MK-333 families single-phase and three-phase AC bidirectional meters from Shenzhen Jiansiyan Technologies Co, Ltd.</li> <li>MycilaWebSerial - WebSerial is a Serial Monitor for ESP32 that can be accessed remotely via a web browser</li> <li>NetWizard - No need to hard-code WiFi credentials ever again. (ESP32, RP2040+W)</li> <li>Sattrack - Track the ISS with ESP8266</li> <li>VZero - the Wireless zero-config controller for volkszaehler.org</li> <li>WebSerial - A remote terminal library for wireless microcontrollers to log, monitor or debug your firmware/product</li> <li>WebSocketToSerial - Debug serial devices through the web browser</li> <li>YaS\u2600\ufe0flR (Yet another Solar Router) - Heat water with your Solar Production Excess with the more powerful and precise solar diverter out there! |</li> </ul>"},{"location":"backup/wiki/#request-variables","title":"Request Variables","text":""},{"location":"backup/wiki/#common-variables","title":"Common Variables","text":"<pre><code>request-&gt;version();       // uint8_t: 0 = HTTP/1.0, 1 = HTTP/1.1\nrequest-&gt;method();        // enum:    HTTP_GET, HTTP_POST, HTTP_DELETE, HTTP_PUT, HTTP_PATCH, HTTP_HEAD, HTTP_OPTIONS\nrequest-&gt;url();           // String:  URL of the request (not including host, port or GET parameters)\nrequest-&gt;host();          // String:  The requested host (can be used for virtual hosting)\nrequest-&gt;contentType();   // String:  ContentType of the request (not available in Handler::canHandle)\nrequest-&gt;contentLength(); // size_t:  ContentLength of the request (not available in Handler::canHandle)\nrequest-&gt;multipart();     // bool:    True if the request has content type \"multipart\"\n</code></pre>"},{"location":"backup/wiki/#headers","title":"Headers","text":"<pre><code>//List all collected headers\nint headers = request-&gt;headers();\nint i;\nfor(i=0;i&lt;headers;i++){\n  const AsyncWebHeader* h = request-&gt;getHeader(i);\n  Serial.printf(\"HEADER[%s]: %s\\n\", h-&gt;name().c_str(), h-&gt;value().c_str());\n}\n\n//get specific header by name\nif(request-&gt;hasHeader(\"MyHeader\")){\n  const AsyncWebHeader* h = request-&gt;getHeader(\"MyHeader\");\n  Serial.printf(\"MyHeader: %s\\n\", h-&gt;value().c_str());\n}\n\n//List all collected headers (Compatibility)\nint headers = request-&gt;headers();\nint i;\nfor(i=0;i&lt;headers;i++){\n  Serial.printf(\"HEADER[%s]: %s\\n\", request-&gt;headerName(i).c_str(), request-&gt;header(i).c_str());\n}\n\n//get specific header by name (Compatibility)\nif(request-&gt;hasHeader(\"MyHeader\")){\n  Serial.printf(\"MyHeader: %s\\n\", request-&gt;header(\"MyHeader\").c_str());\n}\n</code></pre>"},{"location":"backup/wiki/#get-post-and-file-parameters","title":"GET, POST and FILE parameters","text":"<pre><code>//List all parameters\nint params = request-&gt;params();\nfor(int i=0;i&lt;params;i++){\n  AsyncWebParameter* p = request-&gt;getParam(i);\n  if(p-&gt;isFile()){ //p-&gt;isPost() is also true\n    Serial.printf(\"FILE[%s]: %s, size: %u\\n\", p-&gt;name().c_str(), p-&gt;value().c_str(), p-&gt;size());\n  } else if(p-&gt;isPost()){\n    Serial.printf(\"POST[%s]: %s\\n\", p-&gt;name().c_str(), p-&gt;value().c_str());\n  } else {\n    Serial.printf(\"GET[%s]: %s\\n\", p-&gt;name().c_str(), p-&gt;value().c_str());\n  }\n}\n\n//Check if GET parameter exists\nif(request-&gt;hasParam(\"download\"))\n  AsyncWebParameter* p = request-&gt;getParam(\"download\");\n\n//Check if POST (but not File) parameter exists\nif(request-&gt;hasParam(\"download\", true))\n  AsyncWebParameter* p = request-&gt;getParam(\"download\", true);\n\n//Check if FILE was uploaded\nif(request-&gt;hasParam(\"download\", true, true))\n  AsyncWebParameter* p = request-&gt;getParam(\"download\", true, true);\n\n//List all parameters (Compatibility)\nint args = request-&gt;args();\nfor(int i=0;i&lt;args;i++){\n  Serial.printf(\"ARG[%s]: %s\\n\", request-&gt;argName(i).c_str(), request-&gt;arg(i).c_str());\n}\n\n//Check if parameter exists (Compatibility)\nif(request-&gt;hasArg(\"download\"))\n  String arg = request-&gt;arg(\"download\");\n</code></pre>"},{"location":"backup/wiki/#file-upload-handling","title":"FILE Upload handling","text":"<pre><code>void handleUpload(AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){\n  if(!index){\n    Serial.printf(\"UploadStart: %s\\n\", filename.c_str());\n  }\n  for(size_t i=0; i&lt;len; i++){\n    Serial.write(data[i]);\n  }\n  if(final){\n    Serial.printf(\"UploadEnd: %s, %u B\\n\", filename.c_str(), index+len);\n  }\n}\n</code></pre>"},{"location":"backup/wiki/#body-data-handling","title":"Body data handling","text":"<pre><code>void handleBody(AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total){\n  if(!index){\n    Serial.printf(\"BodyStart: %u B\\n\", total);\n  }\n  for(size_t i=0; i&lt;len; i++){\n    Serial.write(data[i]);\n  }\n  if(index + len == total){\n    Serial.printf(\"BodyEnd: %u B\\n\", total);\n  }\n}\n</code></pre> <p>If needed, the <code>_tempObject</code> field on the request can be used to store a pointer to temporary data (e.g. from the body) associated with the request. If assigned, the pointer will automatically be freed along with the request.</p>"},{"location":"backup/wiki/#json-body-handling-with-arduinojson","title":"JSON body handling with ArduinoJson","text":"<p>Endpoints which consume JSON can use a special handler to get ready to use JSON data in the request callback:</p> <pre><code>#include \"AsyncJson.h\"\n#include \"ArduinoJson.h\"\n\nAsyncCallbackJsonWebHandler* handler = new AsyncCallbackJsonWebHandler(\"/rest/endpoint\", [](AsyncWebServerRequest *request, JsonVariant &amp;json) {\n  JsonObject jsonObj = json.as&lt;JsonObject&gt;();\n  // ...\n});\nserver.addHandler(handler);\n</code></pre>"},{"location":"backup/wiki/#responses","title":"Responses","text":""},{"location":"backup/wiki/#redirect-to-another-url","title":"Redirect to another URL","text":"<pre><code>//to local url\nrequest-&gt;redirect(\"/login\");\n\n//to external url\nrequest-&gt;redirect(\"http://esp8266.com\");\n</code></pre>"},{"location":"backup/wiki/#basic-response-with-http-code","title":"Basic response with HTTP Code","text":"<pre><code>request-&gt;send(404); //Sends 404 File Not Found\n</code></pre>"},{"location":"backup/wiki/#basic-response-with-http-code-and-extra-headers","title":"Basic response with HTTP Code and extra headers","text":"<pre><code>AsyncWebServerResponse *response = request-&gt;beginResponse(404); //Sends 404 File Not Found\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#basic-response-with-string-content","title":"Basic response with string content","text":"<pre><code>request-&gt;send(200, \"text/plain\", \"Hello World!\");\n</code></pre>"},{"location":"backup/wiki/#basic-response-with-string-content-and-extra-headers","title":"Basic response with string content and extra headers","text":"<pre><code>AsyncWebServerResponse *response = request-&gt;beginResponse(200, \"text/plain\", \"Hello World!\");\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#send-large-webpage-from-progmem","title":"Send large webpage from PROGMEM","text":"<pre><code>const char index_html[] PROGMEM = \"...\"; // large char array, tested with 14k\nrequest-&gt;send_P(200, \"text/html\", index_html);\n</code></pre>"},{"location":"backup/wiki/#send-large-webpage-from-progmem-and-extra-headers","title":"Send large webpage from PROGMEM and extra headers","text":"<pre><code>const char index_html[] PROGMEM = \"...\"; // large char array, tested with 14k\nAsyncWebServerResponse *response = request-&gt;beginResponse_P(200, \"text/html\", index_html);\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#send-large-webpage-from-progmem-containing-templates","title":"Send large webpage from PROGMEM containing templates","text":"<pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\nconst char index_html[] PROGMEM = \"...\"; // large char array, tested with 14k\nrequest-&gt;send_P(200, \"text/html\", index_html, processor);\n</code></pre>"},{"location":"backup/wiki/#send-large-webpage-from-progmem-containing-templates-and-extra-headers","title":"Send large webpage from PROGMEM containing templates and extra headers","text":"<pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\nconst char index_html[] PROGMEM = \"...\"; // large char array, tested with 14k\nAsyncWebServerResponse *response = request-&gt;beginResponse_P(200, \"text/html\", index_html, processor);\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#send-binary-content-from-progmem","title":"Send binary content from PROGMEM","text":"<pre><code>//File: favicon.ico.gz, Size: 726\n#define favicon_ico_gz_len 726\nconst uint8_t favicon_ico_gz[] PROGMEM = {\n 0x1F, 0x8B, 0x08, 0x08, 0x0B, 0x87, 0x90, 0x57, 0x00, 0x03, 0x66, 0x61, 0x76, 0x69, 0x63, 0x6F,\n 0x6E, 0x2E, 0x69, 0x63, 0x6F, 0x00, 0xCD, 0x53, 0x5F, 0x48, 0x9A, 0x51, 0x14, 0xBF, 0x62, 0x6D,\n 0x86, 0x96, 0xA9, 0x64, 0xD3, 0xFE, 0xA8, 0x99, 0x65, 0x1A, 0xB4, 0x8A, 0xA8, 0x51, 0x54, 0x23,\n 0xA8, 0x11, 0x49, 0x51, 0x8A, 0x34, 0x62, 0x93, 0x85, 0x31, 0x58, 0x44, 0x12, 0x45, 0x2D, 0x58,\n 0xF5, 0x52, 0x41, 0x10, 0x23, 0x82, 0xA0, 0x20, 0x98, 0x2F, 0xC1, 0x26, 0xED, 0xA1, 0x20, 0x89,\n 0x04, 0xD7, 0x83, 0x58, 0x20, 0x28, 0x04, 0xAB, 0xD1, 0x9B, 0x8C, 0xE5, 0xC3, 0x60, 0x32, 0x64,\n 0x0E, 0x56, 0xBF, 0x9D, 0xEF, 0xF6, 0x30, 0x82, 0xED, 0xAD, 0x87, 0xDD, 0x8F, 0xF3, 0xDD, 0x8F,\n 0x73, 0xCF, 0xEF, 0x9C, 0xDF, 0x39, 0xBF, 0xFB, 0x31, 0x26, 0xA2, 0x27, 0x37, 0x97, 0xD1, 0x5B,\n 0xCF, 0x9E, 0x67, 0x30, 0xA6, 0x66, 0x8C, 0x99, 0xC9, 0xC8, 0x45, 0x9E, 0x6B, 0x3F, 0x5F, 0x74,\n 0xA6, 0x94, 0x5E, 0xDB, 0xFF, 0xB2, 0xE6, 0xE7, 0xE7, 0xF9, 0xDE, 0xD6, 0xD6, 0x96, 0xDB, 0xD8,\n 0xD8, 0x78, 0xBF, 0xA1, 0xA1, 0xC1, 0xDA, 0xDC, 0xDC, 0x2C, 0xEB, 0xED, 0xED, 0x15, 0x9B, 0xCD,\n 0xE6, 0x4A, 0x83, 0xC1, 0xE0, 0x2E, 0x29, 0x29, 0x99, 0xD6, 0x6A, 0xB5, 0x4F, 0x75, 0x3A, 0x9D,\n 0x61, 0x75, 0x75, 0x95, 0xB5, 0xB7, 0xB7, 0xDF, 0xC8, 0xD1, 0xD4, 0xD4, 0xF4, 0xB0, 0xBA, 0xBA,\n 0xFA, 0x83, 0xD5, 0x6A, 0xFD, 0x5A, 0x5E, 0x5E, 0x9E, 0x28, 0x2D, 0x2D, 0x0D, 0x10, 0xC6, 0x4B,\n 0x98, 0x78, 0x5E, 0x5E, 0xDE, 0x95, 0x42, 0xA1, 0x40, 0x4E, 0x4E, 0xCE, 0x65, 0x76, 0x76, 0xF6,\n 0x47, 0xB5, 0x5A, 0x6D, 0x4F, 0x26, 0x93, 0xA2, 0xD6, 0xD6, 0x56, 0x8E, 0x6D, 0x69, 0x69, 0xD1,\n 0x11, 0x36, 0x62, 0xB1, 0x58, 0x60, 0x32, 0x99, 0xA0, 0xD7, 0xEB, 0x51, 0x58, 0x58, 0x88, 0xFC,\n 0xFC, 0x7C, 0x10, 0x16, 0x02, 0x56, 0x2E, 0x97, 0x43, 0x2A, 0x95, 0x42, 0x2C, 0x16, 0x23, 0x33,\n 0x33, 0x33, 0xAE, 0x52, 0xA9, 0x1E, 0x64, 0x65, 0x65, 0x71, 0x7C, 0x7D, 0x7D, 0xBD, 0x93, 0xEA,\n 0xFE, 0x30, 0x1A, 0x8D, 0xE8, 0xEC, 0xEC, 0xC4, 0xE2, 0xE2, 0x22, 0x6A, 0x6A, 0x6A, 0x40, 0x39,\n 0x41, 0xB5, 0x38, 0x4E, 0xC8, 0x33, 0x3C, 0x3C, 0x0C, 0x87, 0xC3, 0xC1, 0x6B, 0x54, 0x54, 0x54,\n 0xBC, 0xE9, 0xEB, 0xEB, 0x93, 0x5F, 0x5C, 0x5C, 0x30, 0x8A, 0x9D, 0x2E, 0x2B, 0x2B, 0xBB, 0xA2,\n 0x3E, 0x41, 0xBD, 0x21, 0x1E, 0x8F, 0x63, 0x6A, 0x6A, 0x0A, 0x81, 0x40, 0x00, 0x94, 0x1B, 0x3D,\n 0x3D, 0x3D, 0x42, 0x3C, 0x96, 0x96, 0x96, 0x70, 0x7E, 0x7E, 0x8E, 0xE3, 0xE3, 0x63, 0xF8, 0xFD,\n 0xFE, 0xB4, 0xD7, 0xEB, 0xF5, 0x8F, 0x8F, 0x8F, 0x5B, 0x68, 0x5E, 0x6F, 0x05, 0xCE, 0xB4, 0xE3,\n 0xE8, 0xE8, 0x08, 0x27, 0x27, 0x27, 0xD8, 0xDF, 0xDF, 0xC7, 0xD9, 0xD9, 0x19, 0x6C, 0x36, 0x1B,\n 0x36, 0x36, 0x36, 0x38, 0x9F, 0x85, 0x85, 0x05, 0xAC, 0xAF, 0xAF, 0x23, 0x1A, 0x8D, 0x22, 0x91,\n 0x48, 0x20, 0x16, 0x8B, 0xFD, 0xDA, 0xDA, 0xDA, 0x7A, 0x41, 0x33, 0x7E, 0x57, 0x50, 0x50, 0x80,\n 0x89, 0x89, 0x09, 0x84, 0xC3, 0x61, 0x6C, 0x6F, 0x6F, 0x23, 0x12, 0x89, 0xE0, 0xE0, 0xE0, 0x00,\n 0x43, 0x43, 0x43, 0x58, 0x5E, 0x5E, 0xE6, 0x9C, 0x7D, 0x3E, 0x1F, 0x46, 0x47, 0x47, 0x79, 0xBE,\n 0xBD, 0xBD, 0x3D, 0xE1, 0x3C, 0x1D, 0x0C, 0x06, 0x9F, 0x10, 0xB7, 0xC7, 0x84, 0x4F, 0xF6, 0xF7,\n 0xF7, 0x63, 0x60, 0x60, 0x00, 0x83, 0x83, 0x83, 0x18, 0x19, 0x19, 0xC1, 0xDC, 0xDC, 0x1C, 0x8F,\n 0x17, 0x7C, 0xA4, 0x27, 0xE7, 0x34, 0x39, 0x39, 0x89, 0x9D, 0x9D, 0x1D, 0x6E, 0x54, 0xE3, 0x13,\n 0xE5, 0x34, 0x11, 0x37, 0x49, 0x51, 0x51, 0xD1, 0x4B, 0xA5, 0x52, 0xF9, 0x45, 0x26, 0x93, 0x5D,\n 0x0A, 0xF3, 0x92, 0x48, 0x24, 0xA0, 0x6F, 0x14, 0x17, 0x17, 0xA3, 0xB6, 0xB6, 0x16, 0x5D, 0x5D,\n 0x5D, 0x7C, 0x1E, 0xBB, 0xBB, 0xBB, 0x9C, 0xD7, 0xE1, 0xE1, 0x21, 0x42, 0xA1, 0xD0, 0x6B, 0xD2,\n 0x45, 0x4C, 0x33, 0x12, 0x34, 0xCC, 0xA0, 0x19, 0x54, 0x92, 0x56, 0x0E, 0xD2, 0xD9, 0x43, 0xF8,\n 0xCF, 0x82, 0x56, 0xC2, 0xDC, 0xEB, 0xEA, 0xEA, 0x38, 0x7E, 0x6C, 0x6C, 0x4C, 0xE0, 0xFE, 0x9D,\n 0xB8, 0xBF, 0xA7, 0xFA, 0xAF, 0x56, 0x56, 0x56, 0xEE, 0x6D, 0x6E, 0x6E, 0xDE, 0xB8, 0x47, 0x55,\n 0x55, 0x55, 0x6C, 0x66, 0x66, 0x46, 0x44, 0xDA, 0x3B, 0x34, 0x1A, 0x4D, 0x94, 0xB0, 0x3F, 0x09,\n 0x7B, 0x45, 0xBD, 0xA5, 0x5D, 0x2E, 0x57, 0x8C, 0x7A, 0x73, 0xD9, 0xED, 0xF6, 0x3B, 0x84, 0xFF,\n 0xE7, 0x7D, 0xA6, 0x3A, 0x2C, 0x95, 0x4A, 0xB1, 0x8E, 0x8E, 0x0E, 0x6D, 0x77, 0x77, 0xB7, 0xCD,\n 0xE9, 0x74, 0x3E, 0x73, 0xBB, 0xDD, 0x8F, 0x3C, 0x1E, 0x8F, 0xE6, 0xF4, 0xF4, 0x94, 0xAD, 0xAD,\n 0xAD, 0xDD, 0xDE, 0xCF, 0x73, 0x0B, 0x0B, 0xB8, 0xB6, 0xE0, 0x5D, 0xC6, 0x66, 0xC5, 0xE4, 0x10,\n 0x4C, 0xF4, 0xF7, 0xD8, 0x59, 0xF2, 0x7F, 0xA3, 0xB8, 0xB4, 0xFC, 0x0F, 0xEE, 0x37, 0x70, 0xEC,\n 0x16, 0x4A, 0x7E, 0x04, 0x00, 0x00\n};\n\nAsyncWebServerResponse *response = request-&gt;beginResponse_P(200, \"image/x-icon\", favicon_ico_gz, favicon_ico_gz_len);\nresponse-&gt;addHeader(\"Content-Encoding\", \"gzip\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#respond-with-content-coming-from-a-stream","title":"Respond with content coming from a Stream","text":"<pre><code>//read 12 bytes from Serial and send them as Content Type text/plain\nrequest-&gt;send(Serial, \"text/plain\", 12);\n</code></pre>"},{"location":"backup/wiki/#respond-with-content-coming-from-a-stream-and-extra-headers","title":"Respond with content coming from a Stream and extra headers","text":"<pre><code>//read 12 bytes from Serial and send them as Content Type text/plain\nAsyncWebServerResponse *response = request-&gt;beginResponse(Serial, \"text/plain\", 12);\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#respond-with-content-coming-from-a-stream-containing-templates","title":"Respond with content coming from a Stream containing templates","text":"<pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\n//read 12 bytes from Serial and send them as Content Type text/plain\nrequest-&gt;send(Serial, \"text/plain\", 12, processor);\n</code></pre>"},{"location":"backup/wiki/#respond-with-content-coming-from-a-stream-containing-templates-and-extra-headers","title":"Respond with content coming from a Stream containing templates and extra headers","text":"<pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\n//read 12 bytes from Serial and send them as Content Type text/plain\nAsyncWebServerResponse *response = request-&gt;beginResponse(Serial, \"text/plain\", 12, processor);\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#respond-with-content-coming-from-a-file","title":"Respond with content coming from a File","text":"<pre><code>//Send index.htm with default content type\nrequest-&gt;send(SPIFFS, \"/index.htm\");\n\n//Send index.htm as text\nrequest-&gt;send(SPIFFS, \"/index.htm\", \"text/plain\");\n\n//Download index.htm\nrequest-&gt;send(SPIFFS, \"/index.htm\", String(), true);\n</code></pre>"},{"location":"backup/wiki/#respond-with-content-coming-from-a-file-and-extra-headers","title":"Respond with content coming from a File and extra headers","text":"<pre><code>//Send index.htm with default content type\nAsyncWebServerResponse *response = request-&gt;beginResponse(SPIFFS, \"/index.htm\");\n\n//Send index.htm as text\nAsyncWebServerResponse *response = request-&gt;beginResponse(SPIFFS, \"/index.htm\", \"text/plain\");\n\n//Download index.htm\nAsyncWebServerResponse *response = request-&gt;beginResponse(SPIFFS, \"/index.htm\", String(), true);\n\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#respond-with-content-coming-from-a-file-containing-templates","title":"Respond with content coming from a File containing templates","text":"<p>Internally uses Chunked Response.</p> <p>Index.htm contents:</p> <pre><code>%HELLO_FROM_TEMPLATE%\n</code></pre> <p>Somewhere in source files:</p> <pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\n//Send index.htm with template processor function\nrequest-&gt;send(SPIFFS, \"/index.htm\", String(), false, processor);\n</code></pre>"},{"location":"backup/wiki/#respond-with-content-using-a-callback","title":"Respond with content using a callback","text":"<pre><code>//send 128 bytes as plain text\nrequest-&gt;send(\"text/plain\", 128, [](uint8_t *buffer, size_t maxLen, size_t index) -&gt; size_t {\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\n  //index equals the amount of bytes that have been already sent\n  //You will not be asked for more bytes once the content length has been reached.\n  //Keep in mind that you can not delay or yield waiting for more data!\n  //Send what you currently have and you will be asked for more again\n  return mySource.read(buffer, maxLen);\n});\n</code></pre>"},{"location":"backup/wiki/#respond-with-content-using-a-callback-and-extra-headers","title":"Respond with content using a callback and extra headers","text":"<pre><code>//send 128 bytes as plain text\nAsyncWebServerResponse *response = request-&gt;beginResponse(\"text/plain\", 128, [](uint8_t *buffer, size_t maxLen, size_t index) -&gt; size_t {\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\n  //index equals the amount of bytes that have been already sent\n  //You will not be asked for more bytes once the content length has been reached.\n  //Keep in mind that you can not delay or yield waiting for more data!\n  //Send what you currently have and you will be asked for more again\n  return mySource.read(buffer, maxLen);\n});\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#respond-with-file-content-using-a-callback-and-extra-headers","title":"Respond with file content using a callback and extra headers","text":"<p>With this code your ESP is able to serve even large (large in terms of ESP, e.g. 100kB) files without memory problems.</p> <p>You need to create a file handler in outer function (to have a single one for request) but use it in a lambda. The catch is that the lambda has it's own lifecycle which may/will cause it's called after the original function is over thus the original file handle is destroyed. Using the captured <code>&amp;file</code> in the lambda then causes segfault (Hello, Exception 9!) and the whole ESP crashes. By using this code, you tell the compiler to move the handle into the lambda so it won't be destroyed when outer function (that one where you call <code>request-&gt;send(response)</code>) ends.</p> <pre><code>const File file = ... // e.g. SPIFFS.open(path, \"r\");\n\nconst contentType = \"application/javascript\";\n\nAsyncWebServerResponse *response = request-&gt;beginResponse(\n  contentType,\n  file.size(),\n  [file](uint8_t *buffer, size_t maxLen, size_t total) mutable -&gt; size_t {\n     int bytes = file.read(buffer, maxLen);\n\n     // close file at the end\n     if (bytes + total == file.size()) file.close();\n\n     return max(0, bytes); // return 0 even when no bytes were loaded\n   }\n);\n\nif (gzipped) {\n  response-&gt;addHeader(F(\"Content-Encoding\"), F(\"gzip\"));\n}\n\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#respond-with-content-using-a-callback-containing-templates","title":"Respond with content using a callback containing templates","text":"<pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\n//send 128 bytes as plain text\nrequest-&gt;send(\"text/plain\", 128, [](uint8_t *buffer, size_t maxLen, size_t index) -&gt; size_t {\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\n  //index equals the amount of bytes that have been already sent\n  //You will not be asked for more bytes once the content length has been reached.\n  //Keep in mind that you can not delay or yield waiting for more data!\n  //Send what you currently have and you will be asked for more again\n  return mySource.read(buffer, maxLen);\n}, processor);\n</code></pre>"},{"location":"backup/wiki/#respond-with-content-using-a-callback-containing-templates-and-extra-headers","title":"Respond with content using a callback containing templates and extra headers","text":"<pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\n//send 128 bytes as plain text\nAsyncWebServerResponse *response = request-&gt;beginResponse(\"text/plain\", 128, [](uint8_t *buffer, size_t maxLen, size_t index) -&gt; size_t {\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\n  //index equals the amount of bytes that have been already sent\n  //You will not be asked for more bytes once the content length has been reached.\n  //Keep in mind that you can not delay or yield waiting for more data!\n  //Send what you currently have and you will be asked for more again\n  return mySource.read(buffer, maxLen);\n}, processor);\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#chunked-response","title":"Chunked Response","text":"<p>Used when content length is unknown. Works best if the client supports HTTP/1.1</p> <pre><code>AsyncWebServerResponse *response = request-&gt;beginChunkedResponse(\"text/plain\", [](uint8_t *buffer, size_t maxLen, size_t index) -&gt; size_t {\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\n  //index equals the amount of bytes that have been already sent\n  //You will be asked for more data until 0 is returned\n  //Keep in mind that you can not delay or yield waiting for more data!\n  return mySource.read(buffer, maxLen);\n});\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#chunked-response-containing-templates","title":"Chunked Response containing templates","text":"<p>Used when content length is unknown. Works best if the client supports HTTP/1.1</p> <pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\nAsyncWebServerResponse *response = request-&gt;beginChunkedResponse(\"text/plain\", [](uint8_t *buffer, size_t maxLen, size_t index) -&gt; size_t {\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\n  //index equals the amount of bytes that have been already sent\n  //You will be asked for more data until 0 is returned\n  //Keep in mind that you can not delay or yield waiting for more data!\n  return mySource.read(buffer, maxLen);\n}, processor);\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#print-to-response","title":"Print to response","text":"<pre><code>AsyncResponseStream *response = request-&gt;beginResponseStream(\"text/html\");\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nresponse-&gt;printf(\"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Webpage at %s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\", request-&gt;url().c_str());\n\nresponse-&gt;print(\"&lt;h2&gt;Hello \");\nresponse-&gt;print(request-&gt;client()-&gt;remoteIP());\nresponse-&gt;print(\"&lt;/h2&gt;\");\n\nresponse-&gt;print(\"&lt;h3&gt;General&lt;/h3&gt;\");\nresponse-&gt;print(\"&lt;ul&gt;\");\nresponse-&gt;printf(\"&lt;li&gt;Version: HTTP/1.%u&lt;/li&gt;\", request-&gt;version());\nresponse-&gt;printf(\"&lt;li&gt;Method: %s&lt;/li&gt;\", request-&gt;methodToString());\nresponse-&gt;printf(\"&lt;li&gt;URL: %s&lt;/li&gt;\", request-&gt;url().c_str());\nresponse-&gt;printf(\"&lt;li&gt;Host: %s&lt;/li&gt;\", request-&gt;host().c_str());\nresponse-&gt;printf(\"&lt;li&gt;ContentType: %s&lt;/li&gt;\", request-&gt;contentType().c_str());\nresponse-&gt;printf(\"&lt;li&gt;ContentLength: %u&lt;/li&gt;\", request-&gt;contentLength());\nresponse-&gt;printf(\"&lt;li&gt;Multipart: %s&lt;/li&gt;\", request-&gt;multipart()?\"true\":\"false\");\nresponse-&gt;print(\"&lt;/ul&gt;\");\n\nresponse-&gt;print(\"&lt;h3&gt;Headers&lt;/h3&gt;\");\nresponse-&gt;print(\"&lt;ul&gt;\");\nint headers = request-&gt;headers();\nfor(int i=0;i&lt;headers;i++){\n  AsyncWebHeader* h = request-&gt;getHeader(i);\n  response-&gt;printf(\"&lt;li&gt;%s: %s&lt;/li&gt;\", h-&gt;name().c_str(), h-&gt;value().c_str());\n}\nresponse-&gt;print(\"&lt;/ul&gt;\");\n\nresponse-&gt;print(\"&lt;h3&gt;Parameters&lt;/h3&gt;\");\nresponse-&gt;print(\"&lt;ul&gt;\");\nint params = request-&gt;params();\nfor(int i=0;i&lt;params;i++){\n  AsyncWebParameter* p = request-&gt;getParam(i);\n  if(p-&gt;isFile()){\n    response-&gt;printf(\"&lt;li&gt;FILE[%s]: %s, size: %u&lt;/li&gt;\", p-&gt;name().c_str(), p-&gt;value().c_str(), p-&gt;size());\n  } else if(p-&gt;isPost()){\n    response-&gt;printf(\"&lt;li&gt;POST[%s]: %s&lt;/li&gt;\", p-&gt;name().c_str(), p-&gt;value().c_str());\n  } else {\n    response-&gt;printf(\"&lt;li&gt;GET[%s]: %s&lt;/li&gt;\", p-&gt;name().c_str(), p-&gt;value().c_str());\n  }\n}\nresponse-&gt;print(\"&lt;/ul&gt;\");\n\nresponse-&gt;print(\"&lt;/body&gt;&lt;/html&gt;\");\n//send the response last\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#arduinojson-basic-response","title":"ArduinoJson Basic Response","text":"<p>This way of sending Json is great for when the result is below 4KB</p> <pre><code>#include \"AsyncJson.h\"\n#include \"ArduinoJson.h\"\n\n\nAsyncResponseStream *response = request-&gt;beginResponseStream(\"application/json\");\nDynamicJsonBuffer jsonBuffer;\nJsonObject &amp;root = jsonBuffer.createObject();\nroot[\"heap\"] = ESP.getFreeHeap();\nroot[\"ssid\"] = WiFi.SSID();\nroot.printTo(*response);\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#arduinojson-advanced-response","title":"ArduinoJson Advanced Response","text":"<p>This response can handle really large Json objects (tested to 40KB) There isn't any noticeable speed decrease for small results with the method above Since ArduinoJson does not allow reading parts of the string, the whole Json has to be passed every time a chunks needs to be sent, which shows speed decrease proportional to the resulting json packets</p> <pre><code>#include \"AsyncJson.h\"\n#include \"ArduinoJson.h\"\n\n\nAsyncJsonResponse * response = new AsyncJsonResponse();\nresponse-&gt;addHeader(\"Server\",\"ESP Async Web Server\");\nJsonObject&amp; root = response-&gt;getRoot();\nroot[\"heap\"] = ESP.getFreeHeap();\nroot[\"ssid\"] = WiFi.SSID();\nresponse-&gt;setLength();\nrequest-&gt;send(response);\n</code></pre>"},{"location":"backup/wiki/#serving-static-files","title":"Serving static files","text":"<p>In addition to serving files from SPIFFS as described above, the server provide a dedicated handler that optimize the performance of serving files from SPIFFS - <code>AsyncStaticWebHandler</code>. Use <code>server.serveStatic()</code> function to initialize and add a new instance of <code>AsyncStaticWebHandler</code> to the server. The Handler will not handle the request if the file does not exists, e.g. the server will continue to look for another handler that can handle the request. Notice that you can chain setter functions to setup the handler, or keep a pointer to change it at a later time.</p>"},{"location":"backup/wiki/#serving-specific-file-by-name","title":"Serving specific file by name","text":"<pre><code>// Serve the file \"/www/page.htm\" when request url is \"/page.htm\"\nserver.serveStatic(\"/page.htm\", SPIFFS, \"/www/page.htm\");\n</code></pre>"},{"location":"backup/wiki/#serving-files-in-directory","title":"Serving files in directory","text":"<p>To serve files in a directory, the path to the files should specify a directory in SPIFFS and ends with \"/\".</p> <pre><code>// Serve files in directory \"/www/\" when request url starts with \"/\"\n// Request to the root or none existing files will try to server the default\n// file name \"index.htm\" if exists\nserver.serveStatic(\"/\", SPIFFS, \"/www/\");\n\n// Server with different default file\nserver.serveStatic(\"/\", SPIFFS, \"/www/\").setDefaultFile(\"default.html\");\n</code></pre>"},{"location":"backup/wiki/#serving-static-files-with-authentication","title":"Serving static files with authentication","text":"<pre><code>server\n    .serveStatic(\"/\", SPIFFS, \"/www/\")\n    .setDefaultFile(\"default.html\")\n    .setAuthentication(\"user\", \"pass\");\n</code></pre>"},{"location":"backup/wiki/#specifying-cache-control-header","title":"Specifying Cache-Control header","text":"<p>It is possible to specify Cache-Control header value to reduce the number of calls to the server once the client loaded the files. For more information on Cache-Control values see Cache-Control</p> <pre><code>// Cache responses for 10 minutes (600 seconds)\nserver.serveStatic(\"/\", SPIFFS, \"/www/\").setCacheControl(\"max-age=600\");\n\n//*** Change Cache-Control after server setup ***\n\n// During setup - keep a pointer to the handler\nAsyncStaticWebHandler* handler = &amp;server.serveStatic(\"/\", SPIFFS, \"/www/\").setCacheControl(\"max-age=600\");\n\n// At a later event - change Cache-Control\nhandler-&gt;setCacheControl(\"max-age=30\");\n</code></pre>"},{"location":"backup/wiki/#specifying-date-modified-header","title":"Specifying Date-Modified header","text":"<p>It is possible to specify Date-Modified header to enable the server to return Not-Modified (304) response for requests with \"If-Modified-Since\" header with the same value, instead of responding with the actual file content.</p> <pre><code>// Update the date modified string every time files are updated\nserver.serveStatic(\"/\", SPIFFS, \"/www/\").setLastModified(\"Mon, 20 Jun 2016 14:00:00 GMT\");\n\n//*** Change last modified value at a later stage ***\n\n// During setup - read last modified value from config or EEPROM\nString date_modified = loadDateModified();\nAsyncStaticWebHandler* handler = &amp;server.serveStatic(\"/\", SPIFFS, \"/www/\");\nhandler-&gt;setLastModified(date_modified);\n\n// At a later event when files are updated\nString date_modified = getNewDateModfied();\nsaveDateModified(date_modified); // Save for next reset\nhandler-&gt;setLastModified(date_modified);\n</code></pre>"},{"location":"backup/wiki/#specifying-template-processor-callback","title":"Specifying Template Processor callback","text":"<p>It is possible to specify template processor for static files. For information on template processor see Respond with content coming from a File containing templates.</p> <pre><code>String processor(const String&amp; var)\n{\n  if(var == \"HELLO_FROM_TEMPLATE\")\n    return F(\"Hello world!\");\n  return String();\n}\n\n// ...\n\nserver.serveStatic(\"/\", SPIFFS, \"/www/\").setTemplateProcessor(processor);\n</code></pre>"},{"location":"backup/wiki/#serving-static-files-by-custom-handling","title":"Serving static files by custom handling","text":"<p>It may happen your static files are too big and the ESP will crash the request before it sends the whole file. In that case, you can handle static files with custom file serving through not found handler.</p> <p>This code below is more-or-less equivalent to this:</p> <pre><code>webServer.serveStatic(\"/\", SPIFFS, STATIC_FILES_PREFIX).setDefaultFile(\"index.html\")\n</code></pre> <p>First, declare the handling function:</p> <pre><code>bool handleStaticFile(AsyncWebServerRequest *request) {\n  String path = STATIC_FILES_PREFIX + request-&gt;url();\n\n  if (path.endsWith(\"/\")) path += F(\"index.html\");\n\n  String contentType = getContentType(path);\n  String pathWithGz = path + \".gz\";\n\n  if (SPIFFS.exists(pathWithGz) || SPIFFS.exists(path)) {\n    bool gzipped = false;\n    if (SPIFFS.exists(pathWithGz)) {\n        gzipped = true;\n        path += \".gz\";\n    }\n\n    // TODO serve the file\n\n    return true;\n  }\n\n  return false;\n}\n</code></pre> <p>And then configure your webserver:</p> <pre><code>webServer.onNotFound([](AsyncWebServerRequest *request) {\n  if (handleStaticFile(request)) return;\n\n  request-&gt;send(404);\n});\n</code></pre> <p>You may want to try Respond with file content using a callback and extra headers For actual serving the file.</p>"},{"location":"backup/wiki/#param-rewrite-with-matching","title":"Param Rewrite With Matching","text":"<p>It is possible to rewrite the request url with parameter match. Here is an example with one parameter: Rewrite for example \"/radio/{frequence}\" -&gt; \"/radio?f={frequence}\"</p> <pre><code>class OneParamRewrite : public AsyncWebRewrite\n{\n  protected:\n    String _urlPrefix;\n    int _paramIndex;\n    String _paramsBackup;\n\n  public:\n  OneParamRewrite(const char* from, const char* to)\n    : AsyncWebRewrite(from, to) {\n\n      _paramIndex = _from.indexOf('{');\n\n      if( _paramIndex &gt;=0 &amp;&amp; _from.endsWith(\"}\")) {\n        _urlPrefix = _from.substring(0, _paramIndex);\n        int index = _params.indexOf('{');\n        if(index &gt;= 0) {\n          _params = _params.substring(0, index);\n        }\n      } else {\n        _urlPrefix = _from;\n      }\n      _paramsBackup = _params;\n  }\n\n  bool match(AsyncWebServerRequest *request) override {\n    if(request-&gt;url().startsWith(_urlPrefix)) {\n      if(_paramIndex &gt;= 0) {\n        _params = _paramsBackup + request-&gt;url().substring(_paramIndex);\n      } else {\n        _params = _paramsBackup;\n      }\n    return true;\n\n    } else {\n      return false;\n    }\n  }\n};\n</code></pre> <p>Usage:</p> <pre><code>  server.addRewrite( new OneParamRewrite(\"/radio/{frequence}\", \"/radio?f={frequence}\") );\n</code></pre>"},{"location":"backup/wiki/#using-filters","title":"Using filters","text":"<p>Filters can be set to <code>Rewrite</code> or <code>Handler</code> in order to control when to apply the rewrite and consider the handler. A filter is a callback function that evaluates the request and return a boolean <code>true</code> to include the item or <code>false</code> to exclude it. Two filter callback are provided for convince:</p> <ul> <li><code>ON_STA_FILTER</code> - return true when requests are made to the STA (station mode) interface.</li> <li><code>ON_AP_FILTER</code> - return true when requests are made to the AP (access point) interface.</li> </ul>"},{"location":"backup/wiki/#serve-different-site-files-in-ap-mode","title":"Serve different site files in AP mode","text":"<pre><code>server.serveStatic(\"/\", SPIFFS, \"/www/\").setFilter(ON_STA_FILTER);\nserver.serveStatic(\"/\", SPIFFS, \"/ap/\").setFilter(ON_AP_FILTER);\n</code></pre>"},{"location":"backup/wiki/#rewrite-to-different-index-on-ap","title":"Rewrite to different index on AP","text":"<pre><code>// Serve the file \"/www/index-ap.htm\" in AP, and the file \"/www/index.htm\" on STA\nserver.rewrite(\"/\", \"index.htm\");\nserver.rewrite(\"/index.htm\", \"index-ap.htm\").setFilter(ON_AP_FILTER);\nserver.serveStatic(\"/\", SPIFFS, \"/www/\");\n</code></pre>"},{"location":"backup/wiki/#serving-different-hosts","title":"Serving different hosts","text":"<pre><code>// Filter callback using request host\nbool filterOnHost1(AsyncWebServerRequest *request) { return request-&gt;host() == \"host1\"; }\n\n// Server setup: server files in \"/host1/\" to requests for \"host1\", and files in \"/www/\" otherwise.\nserver.serveStatic(\"/\", SPIFFS, \"/host1/\").setFilter(filterOnHost1);\nserver.serveStatic(\"/\", SPIFFS, \"/www/\");\n</code></pre>"},{"location":"backup/wiki/#determine-interface-inside-callbacks","title":"Determine interface inside callbacks","text":"<pre><code>  String RedirectUrl = \"http://\";\n  if (ON_STA_FILTER(request)) {\n    RedirectUrl += WiFi.localIP().toString();\n  } else {\n    RedirectUrl += WiFi.softAPIP().toString();\n  }\n  RedirectUrl += \"/index.htm\";\n  request-&gt;redirect(RedirectUrl);\n</code></pre>"},{"location":"backup/wiki/#bad-responses","title":"Bad Responses","text":"<p>Some responses are implemented, but you should not use them, because they do not conform to HTTP. The following example will lead to unclean close of the connection and more time wasted than providing the length of the content</p>"},{"location":"backup/wiki/#respond-with-content-using-a-callback-without-content-length-to-http10-clients","title":"Respond with content using a callback without content length to HTTP/1.0 clients","text":"<pre><code>//This is used as fallback for chunked responses to HTTP/1.0 Clients\nrequest-&gt;send(\"text/plain\", 0, [](uint8_t *buffer, size_t maxLen, size_t index) -&gt; size_t {\n  //Write up to \"maxLen\" bytes into \"buffer\" and return the amount written.\n  //You will be asked for more data until 0 is returned\n  //Keep in mind that you can not delay or yield waiting for more data!\n  return mySource.read(buffer, maxLen);\n});\n</code></pre>"},{"location":"backup/wiki/#async-websocket-plugin","title":"Async WebSocket Plugin","text":"<p>The server includes a web socket plugin which lets you define different WebSocket locations to connect to without starting another listening service or using different port</p>"},{"location":"backup/wiki/#async-websocket-event","title":"Async WebSocket Event","text":"<pre><code>void onEvent(AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len){\n  if(type == WS_EVT_CONNECT){\n    //client connected\n    os_printf(\"ws[%s][%u] connect\\n\", server-&gt;url(), client-&gt;id());\n    client-&gt;printf(\"Hello Client %u :)\", client-&gt;id());\n    client-&gt;ping();\n  } else if(type == WS_EVT_DISCONNECT){\n    //client disconnected\n    os_printf(\"ws[%s][%u] disconnect: %u\\n\", server-&gt;url(), client-&gt;id());\n  } else if(type == WS_EVT_ERROR){\n    //error was received from the other end\n    os_printf(\"ws[%s][%u] error(%u): %s\\n\", server-&gt;url(), client-&gt;id(), *((uint16_t*)arg), (char*)data);\n  } else if(type == WS_EVT_PONG){\n    //pong message was received (in response to a ping request maybe)\n    os_printf(\"ws[%s][%u] pong[%u]: %s\\n\", server-&gt;url(), client-&gt;id(), len, (len)?(char*)data:\"\");\n  } else if(type == WS_EVT_DATA){\n    //data packet\n    AwsFrameInfo * info = (AwsFrameInfo*)arg;\n    if(info-&gt;final &amp;&amp; info-&gt;index == 0 &amp;&amp; info-&gt;len == len){\n      //the whole message is in a single frame and we got all of it's data\n      os_printf(\"ws[%s][%u] %s-message[%llu]: \", server-&gt;url(), client-&gt;id(), (info-&gt;opcode == WS_TEXT)?\"text\":\"binary\", info-&gt;len);\n      if(info-&gt;opcode == WS_TEXT){\n        data[len] = 0;\n        os_printf(\"%s\\n\", (char*)data);\n      } else {\n        for(size_t i=0; i &lt; info-&gt;len; i++){\n          os_printf(\"%02x \", data[i]);\n        }\n        os_printf(\"\\n\");\n      }\n      if(info-&gt;opcode == WS_TEXT)\n        client-&gt;text(\"I got your text message\");\n      else\n        client-&gt;binary(\"I got your binary message\");\n    } else {\n      //message is comprised of multiple frames or the frame is split into multiple packets\n      if(info-&gt;index == 0){\n        if(info-&gt;num == 0)\n          os_printf(\"ws[%s][%u] %s-message start\\n\", server-&gt;url(), client-&gt;id(), (info-&gt;message_opcode == WS_TEXT)?\"text\":\"binary\");\n        os_printf(\"ws[%s][%u] frame[%u] start[%llu]\\n\", server-&gt;url(), client-&gt;id(), info-&gt;num, info-&gt;len);\n      }\n\n      os_printf(\"ws[%s][%u] frame[%u] %s[%llu - %llu]: \", server-&gt;url(), client-&gt;id(), info-&gt;num, (info-&gt;message_opcode == WS_TEXT)?\"text\":\"binary\", info-&gt;index, info-&gt;index + len);\n      if(info-&gt;message_opcode == WS_TEXT){\n        data[len] = 0;\n        os_printf(\"%s\\n\", (char*)data);\n      } else {\n        for(size_t i=0; i &lt; len; i++){\n          os_printf(\"%02x \", data[i]);\n        }\n        os_printf(\"\\n\");\n      }\n\n      if((info-&gt;index + len) == info-&gt;len){\n        os_printf(\"ws[%s][%u] frame[%u] end[%llu]\\n\", server-&gt;url(), client-&gt;id(), info-&gt;num, info-&gt;len);\n        if(info-&gt;final){\n          os_printf(\"ws[%s][%u] %s-message end\\n\", server-&gt;url(), client-&gt;id(), (info-&gt;message_opcode == WS_TEXT)?\"text\":\"binary\");\n          if(info-&gt;message_opcode == WS_TEXT)\n            client-&gt;text(\"I got your text message\");\n          else\n            client-&gt;binary(\"I got your binary message\");\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"backup/wiki/#methods-for-sending-data-to-a-socket-client","title":"Methods for sending data to a socket client","text":"<pre><code>//Server methods\nAsyncWebSocket ws(\"/ws\");\n//printf to a client\nws.printf((uint32_t)client_id, arguments...);\n//printf to all clients\nws.printfAll(arguments...);\n//printf_P to a client\nws.printf_P((uint32_t)client_id, PSTR(format), arguments...);\n//printfAll_P to all clients\nws.printfAll_P(PSTR(format), arguments...);\n//send text to a client\nws.text((uint32_t)client_id, (char*)text);\nws.text((uint32_t)client_id, (uint8_t*)text, (size_t)len);\n//send text from PROGMEM to a client\nws.text((uint32_t)client_id, PSTR(\"text\"));\nconst char flash_text[] PROGMEM = \"Text to send\"\nws.text((uint32_t)client_id, FPSTR(flash_text));\n//send text to all clients\nws.textAll((char*)text);\nws.textAll((uint8_t*)text, (size_t)len);\n//send binary to a client\nws.binary((uint32_t)client_id, (char*)binary);\nws.binary((uint32_t)client_id, (uint8_t*)binary, (size_t)len);\n//send binary from PROGMEM to a client\nconst uint8_t flash_binary[] PROGMEM = { 0x01, 0x02, 0x03, 0x04 };\nws.binary((uint32_t)client_id, flash_binary, 4);\n//send binary to all clients\nws.binaryAll((char*)binary);\nws.binaryAll((uint8_t*)binary, (size_t)len);\n//HTTP Authenticate before switch to Websocket protocol\nws.setAuthentication(\"user\", \"pass\");\n\n//client methods\nAsyncWebSocketClient * client;\n//printf\nclient-&gt;printf(arguments...);\n//printf_P\nclient-&gt;printf_P(PSTR(format), arguments...);\n//send text\nclient-&gt;text((char*)text);\nclient-&gt;text((uint8_t*)text, (size_t)len);\n//send text from PROGMEM\nclient-&gt;text(PSTR(\"text\"));\nconst char flash_text[] PROGMEM = \"Text to send\";\nclient-&gt;text(FPSTR(flash_text));\n//send binary\nclient-&gt;binary((char*)binary);\nclient-&gt;binary((uint8_t*)binary, (size_t)len);\n//send binary from PROGMEM\nconst uint8_t flash_binary[] PROGMEM = { 0x01, 0x02, 0x03, 0x04 };\nclient-&gt;binary(flash_binary, 4);\n</code></pre>"},{"location":"backup/wiki/#direct-access-to-web-socket-message-buffer","title":"Direct access to web socket message buffer","text":"<p>When sending a web socket message using the above methods a buffer is created. Under certain circumstances you might want to manipulate or populate this buffer directly from your application, for example to prevent unnecessary duplications of the data. This example below shows how to create a buffer and print data to it from an ArduinoJson object then send it.</p> <pre><code>void sendDataWs(AsyncWebSocketClient * client)\n{\n    DynamicJsonBuffer jsonBuffer;\n    JsonObject&amp; root = jsonBuffer.createObject();\n    root[\"a\"] = \"abc\";\n    root[\"b\"] = \"abcd\";\n    root[\"c\"] = \"abcde\";\n    root[\"d\"] = \"abcdef\";\n    root[\"e\"] = \"abcdefg\";\n    size_t len = root.measureLength();\n    AsyncWebSocketMessageBuffer * buffer = ws.makeBuffer(len); //  creates a buffer (len + 1) for you.\n    if (buffer) {\n        root.printTo((char *)buffer-&gt;get(), len + 1);\n        if (client) {\n            client-&gt;text(buffer);\n        } else {\n            ws.textAll(buffer);\n        }\n    }\n}\n</code></pre>"},{"location":"backup/wiki/#limiting-the-number-of-web-socket-clients","title":"Limiting the number of web socket clients","text":"<p>Browsers sometimes do not correctly close the websocket connection, even when the close() function is called in javascript. This will eventually exhaust the web server's resources and will cause the server to crash. Periodically calling the cleanClients() function from the main loop() function limits the number of clients by closing the oldest client when the maximum number of clients has been exceeded. This can called be every cycle, however, if you wish to use less power, then calling as infrequently as once per second is sufficient.</p> <pre><code>void loop(){\n  ws.cleanupClients();\n}\n</code></pre>"},{"location":"backup/wiki/#async-event-source-plugin","title":"Async Event Source Plugin","text":"<p>The server includes EventSource (Server-Sent Events) plugin which can be used to send short text events to the browser. Difference between EventSource and WebSockets is that EventSource is single direction, text-only protocol.</p>"},{"location":"backup/wiki/#setup-event-source-on-the-server","title":"Setup Event Source on the server","text":"<pre><code>AsyncWebServer server(80);\nAsyncEventSource events(\"/events\");\n\nvoid setup(){\n  // setup ......\n  events.onConnect([](AsyncEventSourceClient *client){\n    if(client-&gt;lastId()){\n      Serial.printf(\"Client reconnected! Last message ID that it gat is: %u\\n\", client-&gt;lastId());\n    }\n    //send event with message \"hello!\", id current millis\n    // and set reconnect delay to 1 second\n    client-&gt;send(\"hello!\",NULL,millis(),1000);\n  });\n  //HTTP Basic authentication\n  events.setAuthentication(\"user\", \"pass\");\n  server.addHandler(&amp;events);\n  // setup ......\n}\n\nvoid loop(){\n  if(eventTriggered){ // your logic here\n    //send event \"myevent\"\n    events.send(\"my event content\",\"myevent\",millis());\n  }\n}\n</code></pre>"},{"location":"backup/wiki/#setup-event-source-in-the-browser","title":"Setup Event Source in the browser","text":"<pre><code>if (!!window.EventSource) {\n  var source = new EventSource(\"/events\");\n\n  source.addEventListener(\n    \"open\",\n    function (e) {\n      console.log(\"Events Connected\");\n    },\n    false\n  );\n\n  source.addEventListener(\n    \"error\",\n    function (e) {\n      if (e.target.readyState != EventSource.OPEN) {\n        console.log(\"Events Disconnected\");\n      }\n    },\n    false\n  );\n\n  source.addEventListener(\n    \"message\",\n    function (e) {\n      console.log(\"message\", e.data);\n    },\n    false\n  );\n\n  source.addEventListener(\n    \"myevent\",\n    function (e) {\n      console.log(\"myevent\", e.data);\n    },\n    false\n  );\n}\n</code></pre>"},{"location":"backup/wiki/#scanning-for-available-wifi-networks","title":"Scanning for available WiFi Networks","text":"<pre><code>//First request will return 0 results unless you start scan from somewhere else (loop/setup)\n//Do not request more often than 3-5 seconds\nserver.on(\"/scan\", HTTP_GET, [](AsyncWebServerRequest *request){\n  String json = \"[\";\n  int n = WiFi.scanComplete();\n  if(n == -2){\n    WiFi.scanNetworks(true);\n  } else if(n){\n    for (int i = 0; i &lt; n; ++i){\n      if(i) json += \",\";\n      json += \"{\";\n      json += \"\\\"rssi\\\":\"+String(WiFi.RSSI(i));\n      json += \",\\\"ssid\\\":\\\"\"+WiFi.SSID(i)+\"\\\"\";\n      json += \",\\\"bssid\\\":\\\"\"+WiFi.BSSIDstr(i)+\"\\\"\";\n      json += \",\\\"channel\\\":\"+String(WiFi.channel(i));\n      json += \",\\\"secure\\\":\"+String(WiFi.encryptionType(i));\n      json += \",\\\"hidden\\\":\"+String(WiFi.isHidden(i)?\"true\":\"false\");\n      json += \"}\";\n    }\n    WiFi.scanDelete();\n    if(WiFi.scanComplete() == -2){\n      WiFi.scanNetworks(true);\n    }\n  }\n  json += \"]\";\n  request-&gt;send(200, \"application/json\", json);\n  json = String();\n});\n</code></pre>"},{"location":"backup/wiki/#remove-handlers-and-rewrites","title":"Remove handlers and rewrites","text":"<p>Server goes through handlers in same order as they were added. You can't simple add handler with same path to override them. To remove handler:</p> <pre><code>// save callback for particular URL path\nauto handler = server.on(\"/some/path\", [](AsyncWebServerRequest *request){\n  //do something useful\n});\n// when you don't need handler anymore remove it\nserver.removeHandler(&amp;handler);\n\n// same with rewrites\nserver.removeRewrite(&amp;someRewrite);\n\nserver.onNotFound([](AsyncWebServerRequest *request){\n  request-&gt;send(404);\n});\n\n// remove server.onNotFound handler\nserver.onNotFound(NULL);\n\n// remove all rewrites, handlers and onNotFound/onFileUpload/onRequestBody callbacks\nserver.reset();\n</code></pre>"},{"location":"backup/wiki/#setting-up-the-server","title":"Setting up the server","text":"<pre><code>#include \"ESPAsyncTCP.h\"\n#include \"ESPAsyncWebServer.h\"\n\nAsyncWebServer server(80);\nAsyncWebSocket ws(\"/ws\"); // access at ws://[esp ip]/ws\nAsyncEventSource events(\"/events\"); // event source (Server-Sent events)\n\nconst char* ssid = \"your-ssid\";\nconst char* password = \"your-pass\";\nconst char* http_username = \"admin\";\nconst char* http_password = \"admin\";\n\n//flag to use from web update to reboot the ESP\nbool shouldReboot = false;\n\nvoid onRequest(AsyncWebServerRequest *request){\n  //Handle Unknown Request\n  request-&gt;send(404);\n}\n\nvoid onBody(AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total){\n  //Handle body\n}\n\nvoid onUpload(AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){\n  //Handle upload\n}\n\nvoid onEvent(AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len){\n  //Handle WebSocket event\n}\n\nvoid setup(){\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  if (WiFi.waitForConnectResult() != WL_CONNECTED) {\n    Serial.printf(\"WiFi Failed!\\n\");\n    return;\n  }\n\n  // attach AsyncWebSocket\n  ws.onEvent(onEvent);\n  server.addHandler(&amp;ws);\n\n  // attach AsyncEventSource\n  server.addHandler(&amp;events);\n\n  // respond to GET requests on URL /heap\n  server.on(\"/heap\", HTTP_GET, [](AsyncWebServerRequest *request){\n    request-&gt;send(200, \"text/plain\", String(ESP.getFreeHeap()));\n  });\n\n  // upload a file to /upload\n  server.on(\"/upload\", HTTP_POST, [](AsyncWebServerRequest *request){\n    request-&gt;send(200);\n  }, onUpload);\n\n  // send a file when /index is requested\n  server.on(\"/index\", HTTP_ANY, [](AsyncWebServerRequest *request){\n    request-&gt;send(SPIFFS, \"/index.htm\");\n  });\n\n  // HTTP basic authentication\n  server.on(\"/login\", HTTP_GET, [](AsyncWebServerRequest *request){\n    if(!request-&gt;authenticate(http_username, http_password))\n        return request-&gt;requestAuthentication();\n    request-&gt;send(200, \"text/plain\", \"Login Success!\");\n  });\n\n  // Simple Firmware Update Form\n  server.on(\"/update\", HTTP_GET, [](AsyncWebServerRequest *request){\n    request-&gt;send(200, \"text/html\", \"&lt;form method='POST' action='/update' enctype='multipart/form-data'&gt;&lt;input type='file' name='update'&gt;&lt;input type='submit' value='Update'&gt;&lt;/form&gt;\");\n  });\n  server.on(\"/update\", HTTP_POST, [](AsyncWebServerRequest *request){\n    shouldReboot = !Update.hasError();\n    AsyncWebServerResponse *response = request-&gt;beginResponse(200, \"text/plain\", shouldReboot?\"OK\":\"FAIL\");\n    response-&gt;addHeader(\"Connection\", \"close\");\n    request-&gt;send(response);\n  },[](AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){\n    if(!index){\n      Serial.printf(\"Update Start: %s\\n\", filename.c_str());\n      Update.runAsync(true);\n      if(!Update.begin((ESP.getFreeSketchSpace() - 0x1000) &amp; 0xFFFFF000)){\n        Update.printError(Serial);\n      }\n    }\n    if(!Update.hasError()){\n      if(Update.write(data, len) != len){\n        Update.printError(Serial);\n      }\n    }\n    if(final){\n      if(Update.end(true)){\n        Serial.printf(\"Update Success: %uB\\n\", index+len);\n      } else {\n        Update.printError(Serial);\n      }\n    }\n  });\n\n  // attach filesystem root at URL /fs\n  server.serveStatic(\"/fs\", SPIFFS, \"/\");\n\n  // Catch-All Handlers\n  // Any request that can not find a Handler that canHandle it\n  // ends in the callbacks below.\n  server.onNotFound(onRequest);\n  server.onFileUpload(onUpload);\n  server.onRequestBody(onBody);\n\n  server.begin();\n}\n\nvoid loop(){\n  if(shouldReboot){\n    Serial.println(\"Rebooting...\");\n    delay(100);\n    ESP.restart();\n  }\n  static char temp[128];\n  sprintf(temp, \"Seconds since boot: %u\", millis()/1000);\n  events.send(temp, \"time\"); //send event \"time\"\n}\n</code></pre>"},{"location":"backup/wiki/#setup-global-and-class-functions-as-request-handlers","title":"Setup global and class functions as request handlers","text":"<pre><code>#include &lt;Arduino.h&gt;\n#include &lt;ESPAsyncWebserver.h&gt;\n#include &lt;Hash.h&gt;\n#include &lt;functional&gt;\n\nvoid handleRequest(AsyncWebServerRequest *request){}\n\nclass WebClass {\npublic :\n  AsyncWebServer classWebServer = AsyncWebServer(81);\n\n  WebClass(){};\n\n  void classRequest (AsyncWebServerRequest *request){}\n\n  void begin(){\n    // attach global request handler\n    classWebServer.on(\"/example\", HTTP_ANY, handleRequest);\n\n    // attach class request handler\n    classWebServer.on(\"/example\", HTTP_ANY, std::bind(&amp;WebClass::classRequest, this, std::placeholders::_1));\n  }\n};\n\nAsyncWebServer globalWebServer(80);\nWebClass webClassInstance;\n\nvoid setup() {\n  // attach global request handler\n  globalWebServer.on(\"/example\", HTTP_ANY, handleRequest);\n\n  // attach class request handler\n  globalWebServer.on(\"/example\", HTTP_ANY, std::bind(&amp;WebClass::classRequest, webClassInstance, std::placeholders::_1));\n}\n\nvoid loop() {\n\n}\n</code></pre>"},{"location":"backup/wiki/#methods-for-controlling-websocket-connections","title":"Methods for controlling websocket connections","text":"<pre><code>  // Disable client connections if it was activated\n  if ( ws.enabled() )\n    ws.enable(false);\n\n  // enable client connections if it was disabled\n  if ( !ws.enabled() )\n    ws.enable(true);\n</code></pre> <p>Example of OTA code</p> <pre><code>  // OTA callbacks\n  ArduinoOTA.onStart([]() {\n    // Clean SPIFFS\n    SPIFFS.end();\n\n    // Disable client connections\n    ws.enable(false);\n\n    // Advertise connected clients what's going on\n    ws.textAll(\"OTA Update Started\");\n\n    // Close them\n    ws.closeAll();\n\n  });\n</code></pre>"},{"location":"backup/wiki/#adding-default-headers","title":"Adding Default Headers","text":"<p>In some cases, such as when working with CORS, or with some sort of custom authentication system, you might need to define a header that should get added to all responses (including static, websocket and EventSource). The DefaultHeaders singleton allows you to do this.</p> <p>Example:</p> <pre><code>DefaultHeaders::Instance().addHeader(\"Access-Control-Allow-Origin\", \"*\");\nwebServer.begin();\n</code></pre> <p>NOTE: You will still need to respond to the OPTIONS method for CORS pre-flight in most cases. (unless you are only using GET)</p> <p>This is one option:</p> <pre><code>webServer.onNotFound([](AsyncWebServerRequest *request) {\n  if (request-&gt;method() == HTTP_OPTIONS) {\n    request-&gt;send(200);\n  } else {\n    request-&gt;send(404);\n  }\n});\n</code></pre>"},{"location":"backup/wiki/#path-variable","title":"Path variable","text":"<p>With path variable you can create a custom regex rule for a specific parameter in a route. For example we want a <code>sensorId</code> parameter in a route rule to match only a integer.</p> <pre><code>  server.on(\"^\\\\/sensor\\\\/([0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest *request) {\n      String sensorId = request-&gt;pathArg(0);\n  });\n</code></pre> <p>NOTE: All regex patterns starts with <code>^</code> and ends with <code>$</code></p> <p>To enable the <code>Path variable</code> support, you have to define the buildflag <code>-DASYNCWEBSERVER_REGEX</code>.</p> <p>For Arduino IDE create/update <code>platform.local.txt</code>:</p> <p><code>Windows</code>: C:\\Users(username)\\AppData\\Local\\Arduino15\\packages\\<code>{espxxxx}</code>\\hardware\\<code>espxxxx</code>\\<code>{version}</code>\\platform.local.txt</p> <p><code>Linux</code>: ~/.arduino15/packages/<code>{espxxxx}</code>/hardware/<code>{espxxxx}</code>/<code>{version}</code>/platform.local.txt</p> <p>Add/Update the following line:</p> <pre><code>  compiler.cpp.extra_flags=-DASYNCWEBSERVER_REGEX\n</code></pre> <p>For platformio modify <code>platformio.ini</code>:</p> <pre><code>[env:myboard]\nbuild_flags =\n  -DASYNCWEBSERVER_REGEX\n</code></pre> <p>NOTE: By enabling <code>ASYNCWEBSERVER_REGEX</code>, <code>&lt;regex&gt;</code> will be included. This will add an 100k to your binary.</p>"}]}